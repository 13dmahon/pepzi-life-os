=== BACKEND ROUTES ===

--- goals.ts ---
import { Router, Request, Response } from 'express';
import { supabase } from '../services/supabase';
import { openai, simpleCompletion } from '../services/openai';
import axios from 'axios';

const router = Router();

// ============================================================
// üèÜ ELITE COACH SYSTEM PROMPT
// ============================================================

const ELITE_COACH_PROMPT = `You are an elite performance coach integrated into Pepzi, a life operating system.

## YOUR PERSONALITY
- Direct but supportive - like a coach who genuinely wants the user to succeed
- Evidence-based - you cite real training principles, not generic advice
- Honest about challenges - you don't sugarcoat unrealistic goals
- Collaborative - you work WITH the user, not lecture them

## CONVERSATION PHASES

### PHASE 1: ACKNOWLEDGE & UNDERSTAND
When user states a goal:
1. Acknowledge their ambition genuinely (1 sentence)
2. Show you understand what this goal REALLY means (the difficulty, what it entails)
3. Identify the BINARY SUCCESS CONDITION (the "unlock" - either achieved or not)
4. Ask 1-2 specific questions about their CURRENT LEVEL

Example response style:
"A sub-20 5K is a serious milestone - that's holding 4:00/km pace for the full distance, which puts you in the top 10% of recreational runners. Let me help you build a plan to get there.

Where are you starting from? What's your current 5K time, and how many times per week are you running right now?"

### PHASE 2: REALITY CHECK
Once you know current level + goal + timeline:
1. Calculate the GAP (where they are vs where they want to be)
2. Assess timeline as REALISTIC, AGGRESSIVE, or UNREALISTIC
3. Be honest but constructive

- REALISTIC: "This is achievable with consistent effort"
- AGGRESSIVE: "This is ambitious - here's what it'll take..."
- UNREALISTIC: "I want to be straight with you - this needs adjustment"

Always explain WHY with specifics, not vague statements.

### PHASE 3: SCHEDULE REALITY CHECK
You'll receive the user's availability context. Use it:
- If capacity exists: "This fits within your available time"
- If tight: "This will use most of your remaining free hours"
- If won't fit: "We have a scheduling challenge - you'd need X hours but only have Y available"

### PHASE 4: BUILD THE PLAN
Propose a SPECIFIC plan with:
1. **Final Milestone**: The binary unlock condition
2. **Total Hours**: CALCULATED based on goal type and gap (NOT a default)
3. **Weekly Hours**: Based on timeline and total (NOT a default 6h)
4. **Sessions Per Week**: Based on what the goal requires (NOT a default 3)
5. **Training Structure**: What types of sessions/activities are needed
6. **Key Milestones**: 3-6 checkpoints with specific criteria

Then ask: "Does this commitment level work for you?"

### PHASE 5: NEGOTIATE
If user wants changes:
- Fewer hours ‚Üí Timeline extends (explain tradeoff)
- Shorter timeline ‚Üí More hours needed (check capacity)
- Can't do required sessions ‚Üí Suggest alternatives or adjust goal

### PHASE 6: CONFIRM
Final summary with exact numbers:
- Goal (binary success condition)
- X hours/week for Y weeks
- Z sessions per week
- Total: N hours
- Fits within their W remaining hours of capacity

## GOAL-SPECIFIC KNOWLEDGE

### RUNNING
- Beginner to completing 5K: 8-12 weeks, 3-4 runs/week, 3-4h/week, ~30-40h total
- 5K time improvement (10%): 6-8 weeks, 4 runs/week, 4-5h/week, ~35-45h total
- 5K time improvement (20%+): 12-16 weeks, 4-5 runs/week, 5-6h/week, ~70-90h total
- Sub-20 5K: Requires 40-45km/week base, 5-6 runs/week, serious commitment
- Marathon: 16-20 weeks, 4-5 runs/week, 6-10h/week, ~100-150h total

### STRENGTH & PHYSIQUE
- Beginner strength foundations: 12 weeks, 3 sessions/week, 3-4h/week, ~40-50h total
- Muscle building (noticeable): 16-24 weeks, 4 sessions/week, 5-6h/week, ~80-120h total
- Specific lift goals (e.g., 100kg bench): Highly dependent on current level, typically 12-24 weeks
- Bodybuilder physique: 6-12+ months, 5-6 sessions/week, 8-10h/week

### SKILL ACQUISITION (General)
- Basic proficiency: 20-50 hours
- Intermediate competence: 100-300 hours
- Advanced level: 500-1000 hours
- Expert/Professional: 1000-5000+ hours
- Key: Frequency beats duration (daily practice > weekly cramming)

### LANGUAGES
Difficulty tiers (for English speakers):
- Tier 1 (Spanish, French, Italian): 400-600 hours to conversational (B1/B2)
- Tier 2 (German, Indonesian): 600-750 hours
- Tier 3 (Russian, Hindi, Vietnamese): 900-1100 hours
- Tier 4 (Japanese, Mandarin, Korean, Arabic): 1500-2200 hours

Structure: Daily practice essential. 30-60min/day, 5-7 days/week is optimal.
Mix: Vocabulary (apps) + Grammar (study) + Listening (media) + Speaking (tutors)

### BUSINESS & SIDE PROJECTS
- MVP launch: 50-200 hours depending on complexity
- First paying customer: 100-300 hours (includes learning + building + marketing)
- ¬£500 MRR: 6-12 months, 10-20h/week, highly variable
- ¬£5K MRR: 12-24 months typically for first-timers
- Key: Consistency and iteration matter more than hours

### CLIMBING
- Beginner to V3: 3-6 months, 2-3 sessions/week, focus on technique
- V3 to V5: 6-12 months, 3 sessions/week, add fingerboard
- V5 to V7: 12-24 months, 3-4 sessions/week, structured training blocks

## RESPONSE STYLE RULES
1. Be conversational, not bullet points (unless showing a plan)
2. One main question or topic per response
3. Keep responses focused and under 200 words unless presenting a full plan
4. Be warm but professional
5. Use specific numbers, not vague ranges

## CRITICAL RULES
1. NEVER use generic defaults - always calculate based on the specific goal
2. ALWAYS factor in their schedule capacity when proposing hours
3. ALWAYS identify the binary "unlock" condition
4. Be HONEST about unrealistic timelines - it's kinder long-term
5. Ask about CURRENT LEVEL before proposing any plan
`;

// ============================================================
// üÜï TRACKING METRICS BY CATEGORY
// ============================================================

const TRACKING_METRICS: Record<string, { default: string[]; optional: string[] }> = {
  fitness: {
    default: ['duration_mins', 'effort_level'],
    optional: ['distance_km', 'time_mins', 'heart_rate', 'pain_notes', 'weight_kg', 'reps', 'sets'],
  },
  languages: {
    default: ['duration_mins', 'effort_level'],
    optional: ['new_vocabulary_count', 'conversation_mins', 'lessons_completed'],
  },
  business: {
    default: ['duration_mins', 'tasks_completed'],
    optional: ['revenue', 'users', 'meetings_held', 'blockers'],
  },
  climbing: {
    default: ['duration_mins', 'effort_level'],
    optional: ['highest_grade', 'problems_sent', 'attempts', 'pain_notes'],
  },
  creative: {
    default: ['duration_mins', 'output_count'],
    optional: ['words_written', 'pieces_created', 'practice_quality'],
  },
  skill: {
    default: ['duration_mins', 'effort_level'],
    optional: ['exercises_completed', 'new_concepts_learned'],
  },
  default: {
    default: ['duration_mins', 'effort_level'],
    optional: ['notes'],
  },
};

// ============================================================
// HELPER FUNCTIONS
// ============================================================

/**
 * Build schedule context from user's availability and existing goals
 */
async function buildScheduleContext(userId: string): Promise<string> {
  try {
    const { data: availability } = await supabase
      .from('user_availability')
      .select('*')
      .eq('user_id', userId)
      .single();

    const { data: goals } = await supabase
      .from('goals')
      .select('name, plan, status')
      .eq('user_id', userId)
      .eq('status', 'active');

    if (!availability) {
      return `
USER SCHEDULE: Not yet configured.
Ask if they'd like to set up their weekly availability first, or proceed with goal planning.`;
    }

    const freeHours = availability.total_free_hours_per_week || 0;
    let committedHours = 0;
    const goalBreakdown: string[] = [];

    if (goals && goals.length > 0) {
      goals.forEach((g: any) => {
        const weeklyHours = g.plan?.weekly_hours || 0;
        committedHours += weeklyHours;
        if (weeklyHours > 0) {
          goalBreakdown.push(`  - ${g.name}: ${weeklyHours}h/week`);
        }
      });
    }

    const remainingCapacity = freeHours - committedHours;

    let context = `
USER'S WEEKLY SCHEDULE:
- Total free hours available: ${freeHours}h/week
- Already committed to goals: ${committedHours}h/week
- REMAINING CAPACITY: ${remainingCapacity}h/week`;

    if (goalBreakdown.length > 0) {
      context += `

Current goal commitments:
${goalBreakdown.join('\n')}`;
    }

    if (remainingCapacity < 3) {
      context += `

‚ö†Ô∏è WARNING: User has very limited capacity (${remainingCapacity}h). New goals may require reducing existing commitments or extending timelines significantly.`;
    } else if (remainingCapacity < 10) {
      context += `

‚ö†Ô∏è CAUTION: User has limited remaining capacity. Be mindful when proposing weekly hours.`;
    } else if (remainingCapacity > 30) {
      context += `

‚úÖ User has good capacity available for new goals.`;
    }

    return context;
  } catch (error) {
    console.error('Error building schedule context:', error);
    return 'USER SCHEDULE: Unable to fetch - proceed with goal planning.';
  }
}

/**
 * Generate preview weeks for plan review
 */
async function generatePreviewWeeks(
  goalName: string,
  category: string,
  sessionsPerWeek: number,
  weeklyHours: number,
  totalWeeks: number,
  milestones: any[]
): Promise<{ week1: any; midWeek: any; finalWeek: any }> {
  const midWeekNum = Math.ceil(totalWeeks / 2);
  
  const prompt = `Create detailed training sessions for 3 specific weeks of a ${totalWeeks}-week plan.

GOAL: ${goalName}
CATEGORY: ${category}
SESSIONS PER WEEK: ${sessionsPerWeek}
HOURS PER WEEK: ${weeklyHours}
TOTAL WEEKS: ${totalWeeks}

MILESTONES:
${milestones.map((m: any) => `- Week ${m.week || m.target_week}: ${m.name}`).join('\n')}

Generate sessions for:
1. WEEK 1 (Foundation) - Building basics, establishing habits
2. WEEK ${midWeekNum} (Development) - Increased intensity, building on foundations
3. WEEK ${totalWeeks} (Peak/Taper) - Final preparation for the goal

For each week, create ${sessionsPerWeek} sessions with:
- Specific activity names (not "Session 1")
- Clear descriptions
- Duration in minutes
- Helpful coaching tips

Return JSON:
{
  "week1": {
    "week_number": 1,
    "focus": "Foundation phase focus (5-10 words)",
    "sessions": [
      {
        "name": "Specific session name",
        "description": "What to do",
        "duration_mins": 60,
        "notes": "Coaching tip"
      }
    ]
  },
  "midWeek": {
    "week_number": ${midWeekNum},
    "focus": "Development phase focus",
    "sessions": [...]
  },
  "finalWeek": {
    "week_number": ${totalWeeks},
    "focus": "Peak/taper phase focus",
    "sessions": [...]
  }
}`;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        {
          role: 'system',
          content: `You are an expert ${category} coach creating detailed, progressive training plans. Be specific and practical.`,
        },
        { role: 'user', content: prompt },
      ],
      temperature: 0.4,
      max_tokens: 3000,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) throw new Error('No content returned');

    return JSON.parse(content);
  } catch (error: any) {
    console.error('‚ö†Ô∏è Preview generation failed:', error.message);
    const placeholder = (weekNum: number, focus: string) => ({
      week_number: weekNum,
      focus,
      sessions: Array.from({ length: sessionsPerWeek }, (_, i) => ({
        name: `Session ${i + 1}`,
        description: 'Training session',
        duration_mins: Math.round((weeklyHours * 60) / sessionsPerWeek),
        notes: 'Focus on consistency',
      })),
    });
    return {
      week1: placeholder(1, 'Building foundations'),
      midWeek: placeholder(midWeekNum, 'Development phase'),
      finalWeek: placeholder(totalWeeks, 'Peak preparation'),
    };
  }
}

/**
 * Format week preview for chat display
 */
function formatWeekPreview(week: any): string {
  let output = `\nüìÖ **Week ${week.week_number}** - ${week.focus}\n`;
  week.sessions.forEach((session: any, i: number) => {
    const isLast = i === week.sessions.length - 1;
    output += `${isLast ? '‚îî‚îÄ‚îÄ' : '‚îú‚îÄ‚îÄ'} **${session.name}** (${session.duration_mins}min)\n`;
    output += `${isLast ? '    ' : '‚îÇ   '} ${session.description}\n`;
    if (session.notes) {
      output += `${isLast ? '    ' : '‚îÇ   '} üí° ${session.notes}\n`;
    }
  });
  return output;
}

/**
 * Apply edits to preview weeks based on user request
 */
async function applyPlanEdits(
  currentPreview: { week1: any; midWeek: any; finalWeek: any },
  editRequest: string,
  goalName: string,
  category: string
): Promise<{ updatedPreview: { week1: any; midWeek: any; finalWeek: any }; editSummary: string }> {
  const prompt = `You are editing a training plan based on user feedback.

CURRENT PLAN:
${JSON.stringify(currentPreview, null, 2)}

USER'S EDIT REQUEST: "${editRequest}"

Apply the user's requested changes to ALL weeks (not just one).
Common requests:
- "Change X to Y" ‚Üí Replace that session type across all weeks
- "Make it push/pull/legs" ‚Üí Restructure sessions to follow that split
- "Add more rest" ‚Üí Add rest days or reduce intensity
- "Shorter sessions" ‚Üí Reduce duration

Return JSON:
{
  "updatedPreview": {
    "week1": { ... updated week with changes ... },
    "midWeek": { ... updated week with changes ... },
    "finalWeek": { ... updated week with changes ... }
  },
  "editSummary": "Brief description of what was changed (1 sentence)"
}`;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        {
          role: 'system',
          content: `You are an expert ${category} coach helping customize a training plan for ${goalName}. Apply edits consistently across all weeks.`,
        },
        { role: 'user', content: prompt },
      ],
      temperature: 0.3,
      max_tokens: 3000,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) throw new Error('No content returned');

    return JSON.parse(content);
  } catch (error: any) {
    console.error('‚ö†Ô∏è Edit application failed:', error.message);
    return {
      updatedPreview: currentPreview,
      editSummary: 'Could not apply edit - please try rephrasing',
    };
  }
}

/**
 * Generate a batch of weeks for the training plan
 */
async function generateWeekBatch(
  goalName: string,
  category: string,
  sessionsPerWeek: number,
  weeklyHours: number,
  startWeek: number,
  endWeek: number,
  totalWeeks: number,
  milestones: any[],
  previousWeekFocus?: string,
  planEdits?: any
): Promise<any[]> {
  const milestonesInRange = milestones.filter((m: any) => {
    const targetWeek = m.week || m.target_week;
    return targetWeek && targetWeek >= startWeek && targetWeek <= endWeek;
  });

  const editInstructions = planEdits?.editInstructions || '';

  const prompt = `Create detailed weekly training sessions for weeks ${startWeek}-${endWeek} of a ${totalWeeks}-week plan.

GOAL: ${goalName}
CATEGORY: ${category}
SESSIONS PER WEEK: ${sessionsPerWeek}
HOURS PER WEEK: ${weeklyHours}
${previousWeekFocus ? `PREVIOUS WEEK FOCUS: ${previousWeekFocus} (build on this)` : 'This is the start of the program.'}
${editInstructions ? `\nUSER CUSTOMIZATIONS TO APPLY:\n${editInstructions}` : ''}

MILESTONES IN THIS RANGE:
${milestonesInRange.length > 0 ? milestonesInRange.map((m: any) => `- Week ${m.week || m.target_week}: ${m.name}`).join('\n') : 'None in this range'}

PHASE CONTEXT:
${startWeek <= Math.ceil(totalWeeks * 0.25) ? '- FOUNDATION PHASE: Focus on basics, form, fundamentals' : ''}
${startWeek > Math.ceil(totalWeeks * 0.25) && startWeek <= Math.ceil(totalWeeks * 0.6) ? '- DEVELOPMENT PHASE: Build intensity, add complexity' : ''}
${startWeek > Math.ceil(totalWeeks * 0.6) && startWeek <= Math.ceil(totalWeeks * 0.85) ? '- PEAK PHASE: High intensity, specific preparation' : ''}
${startWeek > Math.ceil(totalWeeks * 0.85) ? '- TAPER/FINAL PHASE: Reduce volume, maintain intensity, prepare for goal' : ''}

Create DETAILED sessions with:
- Specific activity names (not generic like "Session 1")
- Clear descriptions (1-2 sentences)
- Duration in minutes
- Helpful tips or notes

Return JSON:
{
  "weeks": [
    {
      "week_number": ${startWeek},
      "focus": "What this week focuses on (5-10 words)",
      "sessions": [
        {
          "name": "Specific session name",
          "description": "1-2 sentence description of what to do",
          "duration_mins": 60,
          "notes": "Helpful tip or thing to watch for"
        }
      ]
    }
  ]
}`;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        {
          role: 'system',
          content: `You are an expert ${category} coach creating detailed, progressive training plans. 
Be specific and practical. Each session should feel like real coaching advice.
Include helpful tips that show expertise.`,
        },
        { role: 'user', content: prompt },
      ],
      temperature: 0.4,
      max_tokens: 4000,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) return [];

    const parsed = JSON.parse(content);
    return parsed.weeks || [];
  } catch (error: any) {
    console.error(`‚ö†Ô∏è Failed to generate weeks ${startWeek}-${endWeek}:`, error.message);
    return [];
  }
}

/**
 * Generate complete weekly training plan using batched requests
 */
async function generateFullWeeklyPlan(
  goalName: string,
  category: string,
  sessionsPerWeek: number,
  weeklyHours: number,
  totalWeeks: number,
  milestones: any[],
  planEdits?: any
): Promise<{
  weeks: any[];
  summary: string;
  realism_notes: string;
  milestones: any[];
}> {
  console.log(`üìÖ Generating ${totalWeeks}-week training plan in batches...`);
  if (planEdits?.editInstructions) {
    console.log(`  üìù Applying user customizations: ${planEdits.editInstructions}`);
  }

  const BATCH_SIZE = 4;
  const RETRY_BATCH_SIZE = 2;
  const allWeeks: any[] = [];
  let previousWeekFocus: string | undefined;

  for (let startWeek = 1; startWeek <= totalWeeks; startWeek += BATCH_SIZE) {
    const endWeek = Math.min(startWeek + BATCH_SIZE - 1, totalWeeks);
    console.log(`  üîÑ Generating weeks ${startWeek}-${endWeek}...`);

    let batchWeeks = await generateWeekBatch(
      goalName,
      category,
      sessionsPerWeek,
      weeklyHours,
      startWeek,
      endWeek,
      totalWeeks,
      milestones,
      previousWeekFocus,
      planEdits
    );

    if (batchWeeks.length === 0 && endWeek - startWeek + 1 > RETRY_BATCH_SIZE) {
      console.log(`  üîÅ Retrying with smaller batches (${RETRY_BATCH_SIZE} weeks at a time)...`);
      
      for (let retryStart = startWeek; retryStart <= endWeek; retryStart += RETRY_BATCH_SIZE) {
        const retryEnd = Math.min(retryStart + RETRY_BATCH_SIZE - 1, endWeek);
        console.log(`    üîÑ Retry: weeks ${retryStart}-${retryEnd}...`);
        
        const retryWeeks = await generateWeekBatch(
          goalName,
          category,
          sessionsPerWeek,
          weeklyHours,
          retryStart,
          retryEnd,
          totalWeeks,
          milestones,
          previousWeekFocus,
          planEdits
        );
        
        if (retryWeeks.length > 0) {
          batchWeeks.push(...retryWeeks);
          const lastWeek = retryWeeks[retryWeeks.length - 1];
          previousWeekFocus = lastWeek?.focus;
          console.log(`    ‚úÖ Retry succeeded: ${retryWeeks.length} weeks`);
        } else {
          console.log(`    ‚ö†Ô∏è Retry failed, creating placeholders for weeks ${retryStart}-${retryEnd}`);
          for (let w = retryStart; w <= retryEnd; w++) {
            batchWeeks.push({
              week_number: w,
              focus: `Week ${w} training`,
              sessions: Array.from({ length: sessionsPerWeek }, (_, i) => ({
                name: `Session ${i + 1}`,
                description: 'Training session - details to be added',
                duration_mins: Math.round((weeklyHours * 60) / sessionsPerWeek),
                notes: 'Focus on consistency',
              })),
            });
          }
        }
        
        await new Promise((resolve) => setTimeout(resolve, 300));
      }
    }

    if (batchWeeks.length > 0) {
      allWeeks.push(...batchWeeks);
      const lastWeek = batchWeeks[batchWeeks.length - 1];
      previousWeekFocus = lastWeek?.focus;
      console.log(`  ‚úÖ Generated ${batchWeeks.length} weeks`);
    } else {
      console.log(`  ‚ö†Ô∏è Batch returned empty, creating placeholder weeks`);
      for (let w = startWeek; w <= endWeek; w++) {
        allWeeks.push({
          week_number: w,
          focus: `Week ${w} training`,
          sessions: Array.from({ length: sessionsPerWeek }, (_, i) => ({
            name: `Session ${i + 1}`,
            description: 'Training session - details to be added',
            duration_mins: Math.round((weeklyHours * 60) / sessionsPerWeek),
            notes: 'Focus on consistency',
          })),
        });
      }
    }

    if (endWeek < totalWeeks) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  }

  const summary = `Progressive ${totalWeeks}-week training plan for ${goalName}. 
${sessionsPerWeek} sessions per week, ${weeklyHours} hours total weekly commitment.
${milestones.length} key milestones to track progress.`;

  const mappedMilestones = milestones.map((m: any, i: number) => ({
    name: m.name,
    target_week: m.week || m.target_week || Math.round(((i + 1) * totalWeeks) / milestones.length),
    criteria: m.criteria || 'Complete this milestone',
  }));

  console.log(`‚úÖ Generated complete plan: ${allWeeks.length} weeks`);

  return {
    weeks: allWeeks,
    summary,
    realism_notes: `This ${totalWeeks}-week plan is designed for progressive development. Adjust intensity based on how you feel. Rest is important - don't skip recovery.`,
    milestones: mappedMilestones,
  };
}

// ============================================================
// ROUTES
// ============================================================

/**
 * POST /api/goals/from-dreams
 * Extract goals from free-form text
 */
router.post('/from-dreams', async (req: Request, res: Response) => {
  try {
    const { user_id, text } = req.body;

    if (!user_id || !text) {
      return res.status(400).json({
        error: 'Missing required fields',
        required: ['user_id', 'text'],
      });
    }

    console.log(`üéØ Extracting goals from dreams for user ${user_id}`);

    const prompt = `Extract goals from this text and return as JSON array.

Text: "${text}"

Return JSON in this exact format:
{
  "goals": [
    {
      "name": "Goal name (specific and measurable)",
      "category": "fitness|business|skill|languages|career|travel|education|financial|creative|social|health|mental_health|climbing",
      "description": "Brief description",
      "target_date": "YYYY-MM-DD or null",
      "priority": "high|medium|low"
    }
  ]
}

Only return valid JSON, no other text.`;

    const response = await simpleCompletion(prompt);

    let cleanResponse = response.trim();
    if (cleanResponse.startsWith('```json')) {
      cleanResponse = cleanResponse
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '');
    }

    const parsed = JSON.parse(cleanResponse);
    const goals = parsed.goals || [];

    console.log(`‚úÖ Extracted ${goals.length} goals`);

    return res.json({
      goals,
      message: `Found ${goals.length} goals. Review and confirm to save.`,
    });
  } catch (error: any) {
    console.error('‚ùå Goal extraction error:', error);
    return res.status(500).json({
      error: 'Failed to extract goals',
      message: error.message,
    });
  }
});

/**
 * POST /api/goals/conversation
 * Elite Coach conversational goal creation
 */
router.post('/conversation', async (req: Request, res: Response) => {
  try {
    const { user_id, message, conversation_state } = req.body;

    if (!user_id || !message) {
      return res.status(400).json({
        error: 'Missing required fields',
        required: ['user_id', 'message'],
      });
    }

    console.log(`üí¨ Goal conversation: "${message.substring(0, 50)}..."`);

    const history = conversation_state?.history || [];
    history.push({ role: 'user', content: message });

    const phase = conversation_state?.phase || 'collecting';

    const scheduleContext = await buildScheduleContext(user_id);

    // PHASE: TRACKING_CONTRACT
    if (phase === 'tracking_contract' && conversation_state?.goal) {
      const lower = message.toLowerCase();
      
      const userAccepts = /\b(yes|yeah|yep|ok|okay|looks good|sounds good|perfect|fine|happy|that's fine|works|good|confirm|ready|let's go|create|do it|thanks|thank you|cheers|great|awesome|brilliant|that's great|love it|done)\b/.test(lower);

      if (userAccepts) {
        console.log('‚úÖ User accepted tracking contract ‚Äì ready to create goal');
        
        return res.json({
          complete: true,
          goal: conversation_state.goal,
          milestones: conversation_state.milestones,
          tracking_criteria: conversation_state.tracking_metrics || [],
          weekly_hours: conversation_state.weekly_hours,
          total_hours: conversation_state.total_hours,
          sessions_per_week: conversation_state.sessions_per_week,
          plan_edits: conversation_state.plan_edits,
          message: `üéâ Excellent! Creating your "${conversation_state.goal.name}" plan now with your customizations...\n\nI'll track: ${(conversation_state.tracking_metrics || []).join(', ')}\n\nLet's make it happen!`,
          state: {
            ...conversation_state,
            phase: 'done',
            history,
          },
        });
      }

      const category = conversation_state.goal.category || 'default';
      const metrics = TRACKING_METRICS[category] || TRACKING_METRICS.default;
      const allAvailableMetrics = [...metrics.default, ...metrics.optional];

      const modifyPrompt = `User wants to modify what metrics to track for their ${category} goal.
      
Current proposed metrics: ${JSON.stringify(conversation_state.tracking_metrics)}
ALL VALID METRICS (you MUST only use keys from this list): ${JSON.stringify(allAvailableMetrics)}

User said: "${message}"

Update the tracking metrics based on their request. IMPORTANT: Only use metric keys from the "ALL VALID METRICS" list above.
If they want to add something, find the closest matching key from the list. If they want to remove something, remove it.

Return JSON:
{
  "message": "Your response confirming the changes and listing the final metrics",
  "tracking_metrics": ["duration_mins", "effort_level"]
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        response_format: { type: 'json_object' },
        messages: [
          { role: 'system', content: 'You are an elite coach helping set up progress tracking. Be helpful and concise.' },
          { role: 'user', content: modifyPrompt },
        ],
        temperature: 0.3,
        max_tokens: 500,
      });

      const content = response.choices[0]?.message?.content || '{}';
      const parsed = JSON.parse(content);

      return res.json({
        complete: false,
        message: parsed.message,
        state: {
          ...conversation_state,
          tracking_metrics: parsed.tracking_metrics,
          phase: 'tracking_contract',
          history,
        },
      });
    }

    // PHASE: PLAN_PREVIEW
    if (phase === 'plan_preview' && conversation_state?.goal && conversation_state?.preview) {
      const lower = message.toLowerCase();
      
      const userAccepts = /\b(yes|yeah|yep|ok|okay|looks good|sounds good|perfect|fine|happy|that's good|that works|good to go|ready|let's go|thanks|thank you|cheers|great|awesome|brilliant|that's great|love it|done)\b/.test(lower);

      if (userAccepts) {
        console.log('‚úÖ User accepted plan preview ‚Äì moving to tracking contract');

        const category = conversation_state.goal.category || 'default';
        const metrics = TRACKING_METRICS[category] || TRACKING_METRICS.default;
        const defaultMetrics = [...metrics.default];

        let trackingQuestion = `Perfect! Your training plan is locked in. üîí\n\n`;
        trackingQuestion += `**One last thing** - let's set up progress tracking.\n\n`;
        trackingQuestion += `For ${category} goals, I'd typically ask after each session:\n`;
        defaultMetrics.forEach(m => {
          const label = m.replace(/_/g, ' ').replace(/mins?$/i, '(minutes)').replace(/km$/i, '(km)');
          trackingQuestion += `‚Ä¢ ${label}\n`;
        });
        trackingQuestion += `\nOptional extras I could track: ${metrics.optional.map(m => m.replace(/_/g, ' ')).join(', ')}\n\n`;
        trackingQuestion += `Is this good, or would you like to add/remove anything?`;

        return res.json({
          complete: false,
          message: trackingQuestion,
          state: {
            ...conversation_state,
            tracking_metrics: defaultMetrics,
            phase: 'tracking_contract',
            history,
          },
        });
      }

      console.log('‚úèÔ∏è User requesting plan edit');

      const { updatedPreview, editSummary } = await applyPlanEdits(
        conversation_state.preview,
        message,
        conversation_state.goal.name,
        conversation_state.goal.category
      );

      const planEdits = conversation_state.plan_edits || { editInstructions: '' };
      planEdits.editInstructions += `\n- ${message}`;

      let previewMessage = `‚úèÔ∏è ${editSummary}\n\nHere's your updated plan:\n`;
      previewMessage += formatWeekPreview(updatedPreview.week1);
      previewMessage += `\n...\n`;
      previewMessage += formatWeekPreview(updatedPreview.midWeek);
      previewMessage += `\n...\n`;
      previewMessage += formatWeekPreview(updatedPreview.finalWeek);
      previewMessage += `\n\nWant to make any other changes, or does this look good?`;

      return res.json({
        complete: false,
        message: previewMessage,
        state: {
          ...conversation_state,
          preview: updatedPreview,
          plan_edits: planEdits,
          phase: 'plan_preview',
          history,
        },
      });
    }

    // PHASE: REVIEW
    if (
      phase === 'review' &&
      conversation_state?.goal &&
      conversation_state?.milestones
    ) {
      const lower = message.toLowerCase();

      const userAccepts =
        /\b(yes|yeah|yep|ok|okay|looks good|sounds good|perfect|fine|happy|love it|works for me|that's good|that works|agree|let's do it|go ahead|confirm|proceed|thanks|thank you|cheers|great|awesome|brilliant|that's great|done)\b/.test(
          lower
        );

      if (userAccepts) {
        console.log('‚úÖ User accepted commitment ‚Äì generating plan preview');

        const totalWeeks = conversation_state.total_weeks || Math.ceil((conversation_state.total_hours || 50) / (conversation_state.weekly_hours || 5));
        
        const preview = await generatePreviewWeeks(
          conversation_state.goal.name,
          conversation_state.goal.category,
          conversation_state.sessions_per_week || 3,
          conversation_state.weekly_hours || 5,
          totalWeeks,
          conversation_state.milestones || []
        );

        let previewMessage = `Great! Let me show you what your training will look like:\n`;
        previewMessage += formatWeekPreview(preview.week1);
        previewMessage += `\n...\n`;
        previewMessage += formatWeekPreview(preview.midWeek);
        previewMessage += `\n...\n`;
        previewMessage += formatWeekPreview(preview.finalWeek);
        previewMessage += `\n\nüìù **Want to customize anything?** You can say things like:\n`;
        previewMessage += `‚Ä¢ "Change intervals to hill sprints"\n`;
        previewMessage += `‚Ä¢ "Make it push/pull/legs"\n`;
        previewMessage += `‚Ä¢ "Shorter sessions"\n`;
        previewMessage += `‚Ä¢ "Add more rest days"\n\n`;
        previewMessage += `Or if this looks good, just say "looks good" to continue!`;

        return res.json({
          complete: false,
          message: previewMessage,
          preview,
          state: {
            ...conversation_state,
            preview,
            total_weeks: totalWeeks,
            phase: 'plan_preview',
            history,
          },
        });
      }

      console.log('‚ôªÔ∏è User requested changes to plan');

      const updatePrompt = `You are an elite performance coach. The user wants to modify their plan.

CURRENT PLAN:
${JSON.stringify(conversation_state, null, 2)}

${scheduleContext}

USER'S FEEDBACK: "${message}"

Update the plan based on their feedback. Remember:
- If they want FEWER hours/week ‚Üí extend the timeline (more weeks)
- If they want SHORTER timeline ‚Üí increase hours/week (check capacity)
- If they want MORE or FEWER sessions per week ‚Üí adjust accordingly
- If they want different milestones ‚Üí adjust accordingly
- Always recalculate total_hours based on weekly_hours √ó weeks

Respond with JSON only:
{
  "message": "Your conversational response explaining the updated plan and asking if they're happy with it",
  "state": {
    "goal": {
      "name": "Goal name",
      "category": "category",
      "target_date": "YYYY-MM-DD",
      "description": "Description",
      "current_level": "Their starting point",
      "success_condition": "The binary unlock condition"
    },
    "milestones": [
      { "name": "Specific milestone", "hours": 20, "week": 4 }
    ],
    "tracking_criteria": ["duration_mins", "effort_level"],
    "weekly_hours": number,
    "sessions_per_week": number,
    "total_hours": number,
    "total_weeks": number
  }
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        response_format: { type: 'json_object' },
        messages: [
          {
            role: 'system',
            content:
              'You are an elite coach helping refine a training plan. Respond with JSON only.',
          },
          { role: 'user', content: updatePrompt },
        ],
        temperature: 0.4,
        max_tokens: 2000,
      });

      const content = response.choices[0]?.message?.content || '{}';
      const parsed = JSON.parse(content);

      return res.json({
        complete: false,
        message: parsed.message,
        goal: parsed.state?.goal,
        milestones: parsed.state?.milestones || [],
        tracking_criteria: parsed.state?.tracking_criteria || [],
        weekly_hours: parsed.state?.weekly_hours,
        sessions_per_week: parsed.state?.sessions_per_week,
        total_hours: parsed.state?.total_hours,
        state: {
          ...(parsed.state || {}),
          phase: 'review',
          history,
        },
      });
    }

    // PHASE: COLLECTING
    const knownInfo = {
      goal_name: conversation_state?.goal_name || null,
      current_level: conversation_state?.current_level || null,
      timeline: conversation_state?.timeline || null,
      category: conversation_state?.category || null,
      success_condition: conversation_state?.success_condition || null,
    };

    console.log('üìä Known info:', knownInfo);

    const conversationContext = history
      .map((h: any) => `${h.role === 'user' ? 'User' : 'Coach'}: ${h.content}`)
      .join('\n');

    const systemPrompt = ELITE_COACH_PROMPT + '\n\n' + scheduleContext;

    const today = new Date();
    const currentDateStr = today.toISOString().split('T')[0];
    const currentDateReadable = today.toLocaleDateString('en-GB', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });

    const userPrompt = `TODAY'S DATE: ${currentDateReadable} (${currentDateStr})
Use this date to calculate accurate target_date values. For example, if user says "3 months", add 3 months to today's date.

CONVERSATION SO FAR:
${conversationContext}

INFORMATION GATHERED:
- Goal: ${knownInfo.goal_name || 'Not yet identified'}
- Current level: ${knownInfo.current_level || 'Not yet asked'}
- Timeline: ${knownInfo.timeline || 'Not yet specified'}
- Category: ${knownInfo.category || 'Not yet determined'}
- Success condition: ${knownInfo.success_condition || 'Not yet defined'}

YOUR TASK:
Based on the conversation, decide what to do next:

1. If you DON'T have enough info yet (missing goal clarity, current level, or timeline):
   ‚Üí Ask a specific question to fill the most important gap
   ‚Üí Return mode: "question"

2. If you HAVE enough info to propose a plan:
   ‚Üí Create a complete, calculated plan (NOT generic defaults)
   ‚Üí Present it conversationally and ask if it works for them
   ‚Üí Return mode: "plan"

RESPOND WITH JSON:
{
  "mode": "question" or "plan",
  "message": "Your conversational response (as the elite coach)",
  "state": {
    "goal_name": "if identified",
    "current_level": "if known",
    "timeline": "if specified",
    "category": "fitness|business|skill|languages|career|travel|education|financial|creative|social|health|mental_health|climbing",
    "success_condition": "the binary unlock condition",
    
    // ONLY include these if mode is "plan":
    "goal": {
      "name": "Specific goal name",
      "category": "category",
      "target_date": "YYYY-MM-DD",
      "description": "What this goal means",
      "current_level": "Starting point",
      "success_condition": "Binary unlock condition"
    },
    "milestones": [
      { "name": "Specific measurable milestone", "hours": calculated_hours, "week": target_week }
    ],
    "tracking_criteria": ["duration_mins", "effort_level"],
    "weekly_hours": calculated_number,
    "sessions_per_week": calculated_number,
    "total_hours": calculated_number,
    "total_weeks": calculated_number
  }
}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      temperature: 0.5,
      max_tokens: 2500,
    });

    const content = response.choices[0]?.message?.content || '{}';
    const parsed = JSON.parse(content);

    if (parsed.mode === 'question' || !parsed.state?.goal) {
      const state = {
        goal_name: parsed.state?.goal_name ?? knownInfo.goal_name,
        current_level: parsed.state?.current_level ?? knownInfo.current_level,
        timeline: parsed.state?.timeline ?? knownInfo.timeline,
        category: parsed.state?.category ?? knownInfo.category,
        success_condition:
          parsed.state?.success_condition ?? knownInfo.success_condition,
        phase: 'collecting',
        history,
      };

      console.log('‚ùì Coach asking follow-up question');
      return res.json({
        complete: false,
        message: parsed.message,
        state,
      });
    }

    if (parsed.state?.goal && parsed.state?.milestones) {
      console.log('üìã Coach proposed plan for review');

      return res.json({
        complete: false,
        message: parsed.message,
        goal: parsed.state.goal,
        milestones: parsed.state.milestones,
        tracking_criteria: parsed.state.tracking_criteria || [],
        weekly_hours: parsed.state.weekly_hours,
        sessions_per_week: parsed.state.sessions_per_week,
        total_hours: parsed.state.total_hours,
        state: {
          ...parsed.state,
          phase: 'review',
          history,
        },
      });
    }

    return res.json({
      complete: false,
      message:
        parsed.message ||
        "I'd love to help you with that goal. Could you tell me more about what you want to achieve?",
      state: {
        phase: 'collecting',
        history,
      },
    });
  } catch (error: any) {
    console.error('‚ùå Goal conversation error:', error);
    return res.status(500).json({
      error: 'Failed to process conversation',
      message: 'Sorry, something went wrong. Can you try rephrasing?',
    });
  }
});

/**
 * POST /api/goals
 * Create a new goal
 */
router.post('/', async (req: Request, res: Response) => {
  try {
    const {
      user_id,
      name,
      category,
      target_date,
      description,
      success_condition,
      preferred_days,
      preferred_time,
    } = req.body;

    if (!user_id || !name || !category) {
      return res.status(400).json({
        error: 'Missing required fields',
        required: ['user_id', 'name', 'category'],
      });
    }

    const { data: goal, error } = await supabase
      .from('goals')
      .insert({
        user_id,
        name,
        category,
        target_date: target_date || null,
        status: 'active',
        preferred_days: preferred_days || ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
        preferred_time: preferred_time || 'any',
        plan: {
          description: description || '',
          success_condition: success_condition || '',
          created_at: new Date().toISOString(),
        },
      })
      .select()
      .single();

    if (error) throw error;

    console.log(`‚úÖ Created goal: ${name}`);

    return res.json({
      goal,
      message: 'Goal created successfully',
    });
  } catch (error: any) {
    console.error('‚ùå Goal creation error:', error);
    return res.status(500).json({
      error: 'Failed to create goal',
      message: error.message,
    });
  }
});

/**
 * POST /api/goals/:goalId/create-plan-with-milestones
 * Create training plan with BATCHED weekly plan generation
 */
router.post(
  '/:goalId/create-plan-with-milestones',
  async (req: Request, res: Response) => {
    try {
      const { goalId } = req.params;
      const {
        milestones,
        weekly_hours,
        sessions_per_week,
        total_hours,
        tracking_criteria,
        plan_edits,
      } = req.body;

      console.log(
        `üìã Creating plan for goal ${goalId}: ${weekly_hours}h/week, ${sessions_per_week} sessions`
      );
      if (plan_edits?.editInstructions) {
        console.log(`  üìù With customizations: ${plan_edits.editInstructions}`);
      }

      const { data: goal, error: goalError } = await supabase
        .from('goals')
        .select('*')
        .eq('id', goalId)
        .single();

      if (goalError) throw goalError;
      if (!goal) {
        return res.status(404).json({ error: 'Goal not found' });
      }

      const baseWeekly = Number(weekly_hours) || 5;
      const baseTotal = Number(total_hours) || 50;
      const baseSessions = Number(sessions_per_week) || 3;
      const totalWeeks = Math.max(1, Math.ceil(baseTotal / baseWeekly));
      const safeMilestones: any[] = Array.isArray(milestones) ? milestones : [];

      console.log(`üìä Plan: ${totalWeeks} weeks, ${baseSessions} sessions/week, ${baseWeekly}h/week`);

      const plan: any = {
        weekly_hours: baseWeekly,
        sessions_per_week: baseSessions,
        total_estimated_hours: baseTotal,
        total_weeks: totalWeeks,
        micro_goals: safeMilestones,
        tracking_criteria: Array.isArray(tracking_criteria) ? tracking_criteria : [],
        created_at: new Date().toISOString(),
        custom: true,
      };

      try {
        const weeklyPlan = await generateFullWeeklyPlan(
          goal.name,
          goal.category,
          baseSessions,
          baseWeekly,
          totalWeeks,
          safeMilestones,
          plan_edits
        );

        plan.weekly_plan = weeklyPlan;
        console.log(`‚úÖ Generated ${weeklyPlan.weeks.length} weeks of detailed training`);
      } catch (weeklyErr: any) {
        console.error('‚ö†Ô∏è Weekly plan generation failed:', weeklyErr.message);
        
        plan.weekly_plan = {
          summary: `Progressive ${totalWeeks}-week training plan for ${goal.name}`,
          realism_notes: 'Detailed weekly breakdown could not be generated. Follow your milestones as a guide.',
          weeks: [],
          milestones: safeMilestones.map((m: any, i: number) => ({
            name: m.name,
            target_week: m.week || m.target_week || Math.round(((i + 1) * totalWeeks) / (safeMilestones.length || 1)),
            criteria: m.criteria || 'Complete this milestone',
          })),
        };
      }

      const { error: updateError } = await supabase
        .from('goals')
        .update({ plan })
        .eq('id', goalId);

      if (updateError) throw updateError;

      const microGoalsToInsert = safeMilestones.map((mg: any, index: number) => ({
        goal_id: goalId,
        name: mg.name || `Milestone ${index + 1}`,
        order_index: index + 1,
        completion_criteria: {
          type: 'performance',
          description: mg.criteria || 'Complete milestone',
          hours_required: Number(mg.hours) || 0,
          target_week: mg.week || mg.target_week || null,
        },
      }));

      if (microGoalsToInsert.length > 0) {
        const { error: microError } = await supabase
          .from('micro_goals')
          .insert(microGoalsToInsert);

        if (microError) {
          console.error('‚ö†Ô∏è Micro-goals insert error (non-fatal):', microError);
        }
      }

      const progress = {
        percent_complete: 0,
        completed_micro_goals: 0,
        total_micro_goals: microGoalsToInsert.length,
        last_updated: new Date().toISOString(),
      };

      await supabase.from('goals').update({ progress }).eq('id', goalId);

      console.log(
        `‚úÖ Created plan: ${baseWeekly}h/week, ${baseSessions} sessions, ${totalWeeks} weeks, ${safeMilestones.length} milestones`
      );

      const { data: updatedGoal } = await supabase
        .from('goals')
        .select('*')
        .eq('id', goalId)
        .single();

      if (updatedGoal) {
        try {
          const apiUrl = process.env.API_URL || 'http://localhost:8080';
          const scheduleResponse = await axios.post(
            `${apiUrl}/api/schedule/generate-for-goal`,
            {
              user_id: goal.user_id,
              goal_id: goalId,
              preferred_days: updatedGoal.preferred_days,
              preferred_time: updatedGoal.preferred_time,
            }
          );

          const scheduleResult = scheduleResponse.data;
          console.log(`üìÖ Auto-generated schedule: ${scheduleResult.blocksCreated || 0} blocks`);
          
          return res.json({
            success: true,
            plan,
            schedule: scheduleResult,
            message: `Training plan created and ${scheduleResult.blocksCreated || 0} sessions scheduled!`,
          });
        } catch (scheduleErr: any) {
          console.error('‚ö†Ô∏è Schedule generation failed (non-fatal):', scheduleErr.message);
        }
      }

      return res.json({
        success: true,
        plan,
        message: `Training plan created: ${baseWeekly}h/week for ${totalWeeks} weeks`,
      });
    } catch (error: any) {
      console.error('‚ùå Plan creation error:', error);
      return res.status(500).json({
        error: 'Failed to create plan',
        message: error.message,
      });
    }
  }
);

/**
 * GET /api/goals
 * Get user's goals
 */
router.get('/', async (req: Request, res: Response) => {
  try {
    const { user_id, status } = req.query;

    if (!user_id) {
      return res.status(400).json({
        error: 'Missing user_id query parameter',
      });
    }

    let query = supabase
      .from('goals')
      .select(
        `
        *,
        micro_goals (*)
      `
      )
      .eq('user_id', user_id as string);

    if (status) {
      query = query.eq('status', status as string);
    }

    const { data: goals, error } = await query.order('created_at', {
      ascending: false,
    });

    if (error) throw error;

    return res.json({
      goals: goals || [],
      count: goals?.length || 0,
    });
  } catch (error: any) {
    console.error('‚ùå Goals fetch error:', error);
    return res.status(500).json({
      error: 'Failed to fetch goals',
      message: error.message,
    });
  }
});

/**
 * GET /api/goals/all-progress
 * Get session aggregates for all user's goals
 */
router.get('/all-progress', async (req: Request, res: Response) => {
  try {
    const { user_id } = req.query;

    if (!user_id) {
      return res.status(400).json({ error: 'Missing user_id' });
    }

    console.log(`üìä Fetching progress for all goals of user ${user_id}`);

    const { data: sessions, error } = await supabase
      .from('schedule_blocks')
      .select('goal_id, duration_mins, tracked_data')
      .eq('user_id', user_id)
      .eq('status', 'completed')
      .not('goal_id', 'is', null);

    if (error) throw error;

    const progressByGoal: Record<string, {
      total_sessions: number;
      total_minutes: number;
      total_hours: number;
    }> = {};

    (sessions || []).forEach(s => {
      if (!s.goal_id) return;
      
      if (!progressByGoal[s.goal_id]) {
        progressByGoal[s.goal_id] = {
          total_sessions: 0,
          total_minutes: 0,
          total_hours: 0,
        };
      }
      
      progressByGoal[s.goal_id].total_sessions += 1;
      progressByGoal[s.goal_id].total_minutes += s.duration_mins || 0;
    });

    Object.keys(progressByGoal).forEach(goalId => {
      progressByGoal[goalId].total_hours = 
        Math.round(progressByGoal[goalId].total_minutes / 60 * 10) / 10;
    });

    console.log(`‚úÖ Calculated progress for ${Object.keys(progressByGoal).length} goals`);

    return res.json({ progress: progressByGoal });
  } catch (error: any) {
    console.error('‚ùå All progress fetch error:', error);
    return res.status(500).json({
      error: 'Failed to fetch progress',
      message: error.message,
    });
  }
});

// ============================================================
// üÜï PHASE 2: TIME BUDGET ENDPOINT
// ============================================================

/**
 * GET /api/goals/time-budget
 * Get weekly time breakdown: work, commute, events, training, free
 */
router.get('/time-budget', async (req: Request, res: Response) => {
  try {
    const { user_id } = req.query;

    if (!user_id) {
      return res.status(400).json({ error: 'Missing user_id' });
    }

    console.log(`üìä Calculating time budget for user ${user_id}`);

    // Get user availability for awake hours
    const { data: availability } = await supabase
      .from('user_availability')
      .select('wake_time, sleep_time')
      .eq('user_id', user_id)
      .single();

    // Calculate awake hours per week
    let awakeHoursPerWeek = 112; // Default: 16h * 7 days
    if (availability?.wake_time && availability?.sleep_time) {
      const [wakeH, wakeM] = availability.wake_time.split(':').map(Number);
      const [sleepH, sleepM] = availability.sleep_time.split(':').map(Number);
      const awakeMinutesPerDay = (sleepH * 60 + sleepM) - (wakeH * 60 + wakeM);
      awakeHoursPerWeek = Math.round((awakeMinutesPerDay / 60) * 7 * 10) / 10;
    }

    // Get this week's date range
    const today = new Date();
    const startOfWeek = new Date(today);
    startOfWeek.setDate(today.getDate() - today.getDay());
    startOfWeek.setHours(0, 0, 0, 0);
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 7);

    // Get schedule blocks for this week
    const { data: blocks } = await supabase
      .from('schedule_blocks')
      .select('type, duration_mins, goal_id')
      .eq('user_id', user_id)
      .gte('scheduled_start', startOfWeek.toISOString())
      .lt('scheduled_start', endOfWeek.toISOString());

    // Calculate hours by type
    let workMins = 0;
    let commuteMins = 0;
    let eventMins = 0;
    let trainingMins = 0;

    (blocks || []).forEach(block => {
      const mins = block.duration_mins || 0;
      switch (block.type) {
        case 'work':
          workMins += mins;
          break;
        case 'commute':
          commuteMins += mins;
          break;
        case 'event':
        case 'social':
          eventMins += mins;
          break;
        default:
          if (block.goal_id) {
            trainingMins += mins;
          }
      }
    });

    // Also get training hours from goals (in case schedule hasn't been generated)
    const { data: goals } = await supabase
      .from('goals')
      .select('plan')
      .eq('user_id', user_id)
      .eq('status', 'active');

    const plannedTrainingHours = (goals || []).reduce((sum, g) => sum + (g.plan?.weekly_hours || 0), 0);

    // Use the higher of scheduled or planned training
    const trainingHours = Math.max(
      Math.round(trainingMins / 60 * 10) / 10,
      plannedTrainingHours
    );

    const workHours = Math.round(workMins / 60 * 10) / 10;
    const commuteHours = Math.round(commuteMins / 60 * 10) / 10;
    const eventHours = Math.round(eventMins / 60 * 10) / 10;
    const committedHours = workHours + commuteHours + eventHours + trainingHours;
    const freeHours = Math.max(0, Math.round((awakeHoursPerWeek - committedHours) * 10) / 10);

    console.log(`‚úÖ Time budget: ${workHours}h work, ${commuteHours}h commute, ${eventHours}h events, ${trainingHours}h training, ${freeHours}h free`);

    return res.json({
      work_hours: workHours,
      commute_hours: commuteHours,
      event_hours: eventHours,
      training_hours: trainingHours,
      committed_hours: committedHours,
      awake_hours: awakeHoursPerWeek,
      free_hours: freeHours,
    });
  } catch (error: any) {
    console.error('‚ùå Time budget error:', error);
    return res.status(500).json({
      error: 'Failed to calculate time budget',
      message: error.message,
    });
  }
});

// ============================================================
// üÜï PHASE 2: GOAL INTENSITY & PREFERENCES
// ============================================================

/**
 * PATCH /api/goals/:goalId/intensity
 * Update goal intensity level
 */
router.patch('/:goalId/intensity', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;
    const { intensity } = req.body;

    if (!intensity || !['light', 'standard', 'intense', 'extreme'].includes(intensity)) {
      return res.status(400).json({
        error: 'Invalid intensity. Must be: light, standard, intense, or extreme',
      });
    }

    console.log(`üî• Updating intensity for goal ${goalId} to ${intensity}`);

    const { data: goal, error } = await supabase
      .from('goals')
      .update({ intensity })
      .eq('id', goalId)
      .select()
      .single();

    if (error) throw error;

    return res.json({
      success: true,
      goal,
      message: `Intensity set to ${intensity}`,
    });
  } catch (error: any) {
    console.error('‚ùå Intensity update error:', error);
    return res.status(500).json({
      error: 'Failed to update intensity',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/goals/:goalId/preferences
 * Update goal scheduling preferences (days, hours, sessions)
 */
router.patch('/:goalId/preferences', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;
    const { preferred_days, weekly_hours, sessions_per_week, preferred_time } = req.body;

    console.log(`‚öôÔ∏è Updating preferences for goal ${goalId}`);

    // Get current goal
    const { data: goal, error: fetchError } = await supabase
      .from('goals')
      .select('*')
      .eq('id', goalId)
      .single();

    if (fetchError || !goal) {
      return res.status(404).json({ error: 'Goal not found' });
    }

    // Build updates
    const updates: any = {};
    
    if (preferred_days) {
      updates.preferred_days = preferred_days;
    }
    
    if (preferred_time) {
      updates.preferred_time = preferred_time;
    }

    // Update plan if hours/sessions changed
    if (weekly_hours !== undefined || sessions_per_week !== undefined) {
      const plan = goal.plan || {};
      if (weekly_hours !== undefined) {
        plan.weekly_hours = weekly_hours;
        // Recalculate total weeks
        if (plan.total_estimated_hours) {
          plan.total_weeks = Math.ceil(plan.total_estimated_hours / weekly_hours);
        }
      }
      if (sessions_per_week !== undefined) {
        plan.sessions_per_week = sessions_per_week;
      }
      updates.plan = plan;
    }

    // Update goal
    const { data: updatedGoal, error: updateError } = await supabase
      .from('goals')
      .update(updates)
      .eq('id', goalId)
      .select()
      .single();

    if (updateError) throw updateError;

    // Calculate new target date if weekly hours changed
    let newTargetDate = goal.target_date;
    if (weekly_hours !== undefined && updatedGoal.plan?.total_estimated_hours) {
      const totalWeeks = Math.ceil(updatedGoal.plan.total_estimated_hours / weekly_hours);
      const startDate = new Date(goal.created_at);
      newTargetDate = new Date(startDate);
      newTargetDate.setDate(startDate.getDate() + totalWeeks * 7);
      
      await supabase
        .from('goals')
        .update({ target_date: newTargetDate.toISOString().split('T')[0] })
        .eq('id', goalId);
    }

    return res.json({
      success: true,
      goal: updatedGoal,
      new_target_date: newTargetDate,
      message: 'Preferences updated',
    });
  } catch (error: any) {
    console.error('‚ùå Preferences update error:', error);
    return res.status(500).json({
      error: 'Failed to update preferences',
      message: error.message,
    });
  }
});

/**
 * POST /api/goals/:goalId/intensify-preview
 * Generate a preview of intensified sessions (doesn't save)
 */
router.post('/:goalId/intensify-preview', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;

    console.log(`üî• Generating intensify preview for goal ${goalId}`);

    // Get goal
    const { data: goal, error: fetchError } = await supabase
      .from('goals')
      .select('*')
      .eq('id', goalId)
      .single();

    if (fetchError || !goal) {
      return res.status(404).json({ error: 'Goal not found' });
    }

    // Get future scheduled sessions (limit to 6 for preview)
    const today = new Date();
    const { data: futureSessions, error: sessionsError } = await supabase
      .from('schedule_blocks')
      .select('id, duration_mins, notes, scheduled_start')
      .eq('goal_id', goalId)
      .eq('status', 'scheduled')
      .gt('scheduled_start', today.toISOString())
      .order('scheduled_start', { ascending: true })
      .limit(6);

    if (sessionsError) throw sessionsError;

    if (!futureSessions || futureSessions.length === 0) {
      return res.json({
        success: false,
        message: 'No future sessions to intensify',
        preview: [],
      });
    }

    // Parse current sessions
    const currentSessions = futureSessions.map(s => {
      const [name, description, tip] = (s.notes || '|||').split('|||');
      return {
        id: s.id,
        name: name || 'Training Session',
        description: description || '',
        tip: tip || '',
        duration_mins: s.duration_mins,
        scheduled_start: s.scheduled_start,
      };
    });

    // Use AI to generate intensified versions
    const prompt = `You are an elite ${goal.category} coach. Intensify these training sessions to be 20% more challenging.

GOAL: ${goal.name}
CATEGORY: ${goal.category}

CURRENT SESSIONS:
${currentSessions.map((s, i) => `${i + 1}. "${s.name}" (${s.duration_mins} min)
   Description: ${s.description}
   Tip: ${s.tip}`).join('\n\n')}

For each session, create an INTENSIFIED version that:
- Has a more challenging name (e.g., "Easy Run" ‚Üí "Tempo Run with Hills")
- Has harder description (more reps, heavier weight, faster pace, longer holds, etc.)
- Has a motivating tip that pushes them
- Is 10-20% longer in duration

Return JSON:
{
  "intensified": [
    {
      "original_id": "session id",
      "name": "Intensified session name",
      "description": "Harder description with specific numbers",
      "tip": "Motivating tip",
      "duration_mins": increased_duration
    }
  ]
}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: 'You are an expert coach who knows how to progressively intensify training. Be specific with numbers and targets.' },
        { role: 'user', content: prompt },
      ],
      temperature: 0.4,
      max_tokens: 2000,
    });

    const content = response.choices[0]?.message?.content || '{}';
    const parsed = JSON.parse(content);
    const intensified = parsed.intensified || [];

    // Build preview with before/after
    const preview = currentSessions.map((current, i) => {
      const intense = intensified[i] || {
        name: `Intense ${current.name}`,
        description: `${current.description} - Push harder!`,
        tip: 'Give it your all!',
        duration_mins: Math.round(current.duration_mins * 1.15),
      };

      return {
        id: current.id,
        before: {
          name: current.name,
          description: current.description,
          tip: current.tip,
          duration_mins: current.duration_mins,
        },
        after: {
          name: intense.name,
          description: intense.description,
          tip: intense.tip,
          duration_mins: intense.duration_mins,
        },
      };
    });

    // Count total future sessions
    const { count } = await supabase
      .from('schedule_blocks')
      .select('*', { count: 'exact', head: true })
      .eq('goal_id', goalId)
      .eq('status', 'scheduled')
      .gt('scheduled_start', today.toISOString());

    console.log(`‚úÖ Generated preview for ${preview.length} sessions`);

    return res.json({
      success: true,
      preview,
      total_sessions: count || futureSessions.length,
      message: `Preview of ${preview.length} sessions (${count} total will be updated)`,
    });

  } catch (error: any) {
    console.error('‚ùå Intensify preview error:', error);
    return res.status(500).json({
      error: 'Failed to generate preview',
      message: error.message,
    });
  }
});

/**
 * POST /api/goals/:goalId/intensify-apply
 * Apply intensified sessions (saves to database)
 */
router.post('/:goalId/intensify-apply', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;
    const { preview } = req.body; // Array of { id, after: { name, description, tip, duration_mins } }

    if (!preview || !Array.isArray(preview)) {
      return res.status(400).json({ error: 'Missing preview data' });
    }

    console.log(`üî• Applying intensified sessions for goal ${goalId}`);

    // Get goal for category
    const { data: goal, error: fetchError } = await supabase
      .from('goals')
      .select('*')
      .eq('id', goalId)
      .single();

    if (fetchError || !goal) {
      return res.status(404).json({ error: 'Goal not found' });
    }

    // Get ALL future sessions (not just preview)
    const today = new Date();
    const { data: allFutureSessions, error: sessionsError } = await supabase
      .from('schedule_blocks')
      .select('id, duration_mins, notes, scheduled_start')
      .eq('goal_id', goalId)
      .eq('status', 'scheduled')
      .gt('scheduled_start', today.toISOString())
      .order('scheduled_start', { ascending: true });

    if (sessionsError) throw sessionsError;

    // Update sessions that were in preview
    const previewIds = new Set(preview.map((p: any) => p.id));
    let updatedCount = 0;

    for (const p of preview) {
      const notes = `${p.after.name}|||${p.after.description}|||üî• ${p.after.tip}`;
      
      const { error: updateError } = await supabase
        .from('schedule_blocks')
        .update({
          duration_mins: p.after.duration_mins,
          notes,
        })
        .eq('id', p.id);

      if (!updateError) updatedCount++;
    }

    // For remaining sessions not in preview, apply 15% intensity increase
    const remainingSessions = (allFutureSessions || []).filter(s => !previewIds.has(s.id));
    
    for (const session of remainingSessions) {
      const [name, description, tip] = (session.notes || '|||').split('|||');
      const newDuration = Math.round(session.duration_mins * 1.15);
      const newNotes = `${name}|||${description}|||üî• INTENSIFIED: ${tip || 'Push harder!'}`;

      const { error: updateError } = await supabase
        .from('schedule_blocks')
        .update({
          duration_mins: newDuration,
          notes: newNotes,
        })
        .eq('id', session.id);

      if (!updateError) updatedCount++;
    }

    // Update goal intensity level
    await supabase
      .from('goals')
      .update({ intensity: 'intense' })
      .eq('id', goalId);

    console.log(`‚úÖ Applied intensification to ${updatedCount} sessions`);

    return res.json({
      success: true,
      sessions_updated: updatedCount,
      message: `üî• Intensified ${updatedCount} sessions! Let's go!`,
    });

  } catch (error: any) {
    console.error('‚ùå Intensify apply error:', error);
    return res.status(500).json({
      error: 'Failed to apply intensification',
      message: error.message,
    });
  }
});

/**
 * GET /api/goals/:goalId/sessions
 * Get completed sessions with tracked data for a goal
 */
router.get('/:goalId/sessions', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;
    const { limit = '50' } = req.query;

    console.log(`üìä Fetching sessions for goal ${goalId}`);

    const { data: sessions, error } = await supabase
      .from('schedule_blocks')
      .select('id, scheduled_start, duration_mins, status, completed_at, notes, tracked_data')
      .eq('goal_id', goalId)
      .eq('status', 'completed')
      .order('completed_at', { ascending: false })
      .limit(parseInt(limit as string));

    if (error) throw error;

    const totalSessions = sessions?.length || 0;
    const totalMinutes = sessions?.reduce((sum, s) => sum + (s.duration_mins || 0), 0) || 0;
    const totalHours = Math.round(totalMinutes / 60 * 10) / 10;

    const effortValues = sessions
      ?.map(s => s.tracked_data?.effort_level || s.tracked_data?.effort)
      .filter(e => e !== undefined && e !== null) || [];
    const avgEffort = effortValues.length > 0
      ? Math.round(effortValues.reduce((a, b) => a + b, 0) / effortValues.length * 10) / 10
      : null;

    const distanceValues = sessions
      ?.map(s => s.tracked_data?.distance_km || s.tracked_data?.distance)
      .filter(d => d !== undefined && d !== null) || [];
    const totalDistance = distanceValues.length > 0
      ? Math.round(distanceValues.reduce((a, b) => a + b, 0) * 10) / 10
      : null;

    const formattedSessions = sessions?.map(s => {
      const sessionName = s.notes?.split('|||')[0] || 'Training Session';
      return {
        id: s.id,
        name: sessionName,
        scheduled_start: s.scheduled_start,
        completed_at: s.completed_at,
        duration_mins: s.duration_mins,
        tracked_data: s.tracked_data || {},
      };
    }) || [];

    console.log(`‚úÖ Found ${totalSessions} sessions, ${totalHours}h total`);

    return res.json({
      sessions: formattedSessions,
      aggregates: {
        total_sessions: totalSessions,
        total_hours: totalHours,
        total_minutes: totalMinutes,
        avg_effort: avgEffort,
        total_distance_km: totalDistance,
      },
    });
  } catch (error: any) {
    console.error('‚ùå Sessions fetch error:', error);
    return res.status(500).json({
      error: 'Failed to fetch sessions',
      message: error.message,
    });
  }
});

/**
 * GET /api/goals/:goalId/schedule
 * Get ALL scheduled sessions for a goal (past, present, future)
 */
router.get('/:goalId/schedule', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;

    console.log(`üìÖ Fetching full schedule for goal ${goalId}`);

    const { data: sessions, error } = await supabase
      .from('schedule_blocks')
      .select('*')
      .eq('goal_id', goalId)
      .order('scheduled_start', { ascending: true });

    if (error) throw error;

    // Group by week
    const sessionsByWeek: Record<number, any[]> = {};
    const today = new Date();
    
    // Get goal start date
    const { data: goal } = await supabase
      .from('goals')
      .select('created_at')
      .eq('id', goalId)
      .single();

    const goalStart = goal ? new Date(goal.created_at) : today;
    goalStart.setHours(0, 0, 0, 0);

    (sessions || []).forEach(session => {
      const sessionDate = new Date(session.scheduled_start);
      const weekNum = Math.floor((sessionDate.getTime() - goalStart.getTime()) / (7 * 24 * 60 * 60 * 1000)) + 1;
      
      if (!sessionsByWeek[weekNum]) {
        sessionsByWeek[weekNum] = [];
      }
      
      // Parse notes into name/description/tip
      const [name, description, tip] = (session.notes || '|||').split('|||');
      
      sessionsByWeek[weekNum].push({
        ...session,
        parsed_name: name || 'Training Session',
        parsed_description: description || '',
        parsed_tip: tip || '',
        week_number: weekNum,
        is_past: sessionDate < today,
        is_today: sessionDate.toDateString() === today.toDateString(),
      });
    });

    console.log(`‚úÖ Found ${sessions?.length || 0} sessions across ${Object.keys(sessionsByWeek).length} weeks`);

    return res.json({
      sessions: sessions || [],
      sessions_by_week: sessionsByWeek,
      total_sessions: sessions?.length || 0,
    });
  } catch (error: any) {
    console.error('‚ùå Schedule fetch error:', error);
    return res.status(500).json({
      error: 'Failed to fetch schedule',
      message: error.message,
    });
  }
});

/**
 * DELETE /api/goals/:goalId
 * Delete a goal and all associated data
 */
router.delete('/:goalId', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;

    console.log(`üóëÔ∏è Deleting goal ${goalId} completely`);

    await supabase.from('micro_goals').delete().eq('goal_id', goalId);
    await supabase.from('schedule_blocks').delete().eq('goal_id', goalId);

    const { error: deleteError } = await supabase
      .from('goals')
      .delete()
      .eq('id', goalId);

    if (deleteError) throw deleteError;

    console.log(`‚úÖ Deleted goal ${goalId} completely`);

    return res.json({
      success: true,
      message: 'Goal deleted successfully',
    });
  } catch (error: any) {
    console.error('‚ùå Goal deletion error:', error);
    return res.status(500).json({
      error: 'Failed to delete goal',
      message: error.message,
    });
  }
});

/**
 * DELETE /api/goals/:goalId/plan
 * Delete training plan and micro-goals for a goal
 */
router.delete('/:goalId/plan', async (req: Request, res: Response) => {
  try {
    const { goalId } = req.params;

    console.log(`üóëÔ∏è Deleting plan for goal ${goalId}`);

    await supabase.from('micro_goals').delete().eq('goal_id', goalId);

    const { error: updateError } = await supabase
      .from('goals')
      .update({
        plan: null,
        progress: null,
        updated_at: new Date().toISOString(),
      })
      .eq('id', goalId);

    if (updateError) throw updateError;

    console.log(`‚úÖ Deleted plan for goal ${goalId}`);

    return res.json({
      success: true,
      message: 'Plan deleted successfully',
    });
  } catch (error: any) {
    console.error('‚ùå Plan deletion error:', error);
    return res.status(500).json({
      error: 'Failed to delete plan',
      message: error.message,
    });
  }
});

export default router;
--- schedule.ts ---
import { Router, Request, Response } from 'express';
import { supabase } from '../services/supabase';
import { parseRelativeTime, parseTime, combineDateAndTime } from '../utils/timeParser';
import { rescheduleBlock } from '../services/planner';

const router = Router();

// ============================================================
// HELPER FUNCTIONS
// ============================================================

/**
 * Parse time string to hours/minutes
 */
function parseTimeHelper(timeStr: string): { hours: number; minutes: number } {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return { hours, minutes };
}

/**
 * Convert hours/minutes to total minutes from midnight
 */
function toMinutes(hours: number, minutes: number): number {
  return hours * 60 + minutes;
}

/**
 * Convert minutes from midnight to time string
 */
function fromMinutes(totalMinutes: number): { hours: number; minutes: number } {
  return {
    hours: Math.floor(totalMinutes / 60) % 24,
    minutes: totalMinutes % 60,
  };
}

/**
 * Calculate goal progress and return status message
 */
async function calculateGoalProgress(goalId: string): Promise<{ message: string; daysAhead: number } | null> {
  try {
    // Get goal details
    const { data: goal } = await supabase
      .from('goals')
      .select('*, plan')
      .eq('id', goalId)
      .single();

    if (!goal) return null;

    // Get all completed blocks for this goal
    const { data: completed } = await supabase
      .from('schedule_blocks')
      .select('duration_mins, completed_at')
      .eq('goal_id', goalId)
      .eq('status', 'completed');

    // Get all remaining scheduled blocks
    const { data: remaining } = await supabase
      .from('schedule_blocks')
      .select('scheduled_start')
      .eq('goal_id', goalId)
      .eq('status', 'scheduled')
      .gt('scheduled_start', new Date().toISOString());

    const totalCompleted = completed?.length || 0;
    const totalRemaining = remaining?.length || 0;
    const totalHoursLogged = (completed || []).reduce((sum, b) => sum + (b.duration_mins || 0), 0) / 60;
    const targetHours = goal.plan?.total_estimated_hours || 50;

    // Calculate if ahead or behind
    const percentComplete = Math.round((totalHoursLogged / targetHours) * 100);
    
    // Estimate days ahead/behind based on progress vs expected
    const totalWeeks = goal.plan?.total_weeks || 12;
    const startDate = new Date(goal.created_at);
    const now = new Date();
    const weeksSinceStart = Math.max(1, Math.floor((now.getTime() - startDate.getTime()) / (7 * 24 * 60 * 60 * 1000)));
    const expectedPercent = Math.min(100, Math.round((weeksSinceStart / totalWeeks) * 100));

    const daysAhead = Math.round((percentComplete - expectedPercent) * totalWeeks * 7 / 100);

    let message = '';
    if (daysAhead > 0) {
      message = `You're ${daysAhead} day${daysAhead > 1 ? 's' : ''} ahead! üî•`;
    } else if (daysAhead < 0) {
      message = `${Math.abs(daysAhead)} day${Math.abs(daysAhead) > 1 ? 's' : ''} behind - keep pushing! üí™`;
    } else {
      message = `Right on track! ‚úÖ`;
    }

    return { message, daysAhead };
  } catch (error) {
    console.error('Error calculating progress:', error);
    return null;
  }
}

/**
 * Get available time slots for a day
 * Now handles weekends properly (all day is free if no work)
 */
function getAvailableSlots(
  dayName: string,
  availability: any,
  userBlocksForDay: Array<{ start: number; end: number }> = []
): Array<{ start: number; end: number }> {
  const slots: Array<{ start: number; end: number }> = [];

  // Use availability settings or sensible defaults
  const wake = parseTimeHelper(availability?.wake_time || '06:00');
  const sleep = parseTimeHelper(availability?.sleep_time || '22:00');
  const wakeMinutes = toMinutes(wake.hours, wake.minutes);
  const sleepMinutes = toMinutes(sleep.hours, sleep.minutes);

  // Build blocked times from ALL sources
  const blocked: Array<{ start: number; end: number }> = [];

  // 1. Work schedule from availability (if exists)
  const workSchedule = availability?.work_schedule?.[dayName];
  if (workSchedule && workSchedule.start && workSchedule.end) {
    const workStart = parseTimeHelper(workSchedule.start);
    const workEnd = parseTimeHelper(workSchedule.end);
    blocked.push({
      start: toMinutes(workStart.hours, workStart.minutes),
      end: toMinutes(workEnd.hours, workEnd.minutes),
    });

    // Add commute before/after work
    const commuteMins = availability?.daily_commute_mins || 0;
    if (commuteMins > 0) {
      blocked.push({
        start: toMinutes(workStart.hours, workStart.minutes) - commuteMins,
        end: toMinutes(workStart.hours, workStart.minutes),
      });
      blocked.push({
        start: toMinutes(workEnd.hours, workEnd.minutes),
        end: toMinutes(workEnd.hours, workEnd.minutes) + commuteMins,
      });
    }
  }

  // 2. Fixed commitments from availability (if exists)
  const fixedCommitments = (availability?.fixed_commitments || [])
    .filter((c: any) => c.day?.toLowerCase() === dayName)
    .map((c: any) => ({
      start: toMinutes(...Object.values(parseTimeHelper(c.start)) as [number, number]),
      end: toMinutes(...Object.values(parseTimeHelper(c.end)) as [number, number]),
    }));
  blocked.push(...fixedCommitments);

  // 3. User-created blocks from calendar (work, commute, events added via UI)
  blocked.push(...userBlocksForDay);

  // Sort blocked times
  blocked.sort((a, b) => a.start - b.start);

  // Merge overlapping blocks
  const mergedBlocked: Array<{ start: number; end: number }> = [];
  for (const block of blocked) {
    if (mergedBlocked.length === 0 || block.start > mergedBlocked[mergedBlocked.length - 1].end) {
      mergedBlocked.push({ ...block });
    } else {
      mergedBlocked[mergedBlocked.length - 1].end = Math.max(
        mergedBlocked[mergedBlocked.length - 1].end,
        block.end
      );
    }
  }

  // Find free slots between wake and sleep
  let currentTime = wakeMinutes;

  for (const block of mergedBlocked) {
    if (block.start > currentTime && block.start < sleepMinutes) {
      // Free slot before this block
      slots.push({ start: currentTime, end: Math.min(block.start, sleepMinutes) });
    }
    currentTime = Math.max(currentTime, block.end);
  }

  // Final slot until sleep
  if (currentTime < sleepMinutes) {
    slots.push({ start: currentTime, end: sleepMinutes });
  }

  return slots;
}

/**
 * Find best available slot with VARIED start times
 */
function findBestSlot(
  availableSlots: Array<{ start: number; end: number }>,
  scheduledSlots: Array<{ start: number; end: number; goalId: string }>,
  duration: number,
  preference: 'morning' | 'afternoon' | 'evening' | 'any',
  goalId: string,
  sessionIndex: number = 0
): { start: number; end: number } | null {
  const BUFFER = 15;
  
  const TIME_OFFSETS = [0, 45, 90, 30, 75, 15, 60, 105];
  const offset = TIME_OFFSETS[sessionIndex % TIME_OFFSETS.length];

  const timeRanges = {
    morning: { start: 5 * 60, end: 12 * 60 },
    afternoon: { start: 12 * 60, end: 17 * 60 },
    evening: { start: 17 * 60, end: 23 * 60 },
  };

  const candidateSlots: Array<{ start: number; end: number; score: number }> = [];

  for (const availSlot of availableSlots) {
    const scheduledInSlot = scheduledSlots
      .filter((s) => s.start < availSlot.end && s.end > availSlot.start)
      .sort((a, b) => a.start - b.start);

    let searchStart = availSlot.start;

    for (const scheduled of scheduledInSlot) {
      const gapEnd = scheduled.start - BUFFER;
      if (gapEnd - searchStart >= duration) {
        const adjustedStart = Math.min(searchStart + offset, gapEnd - duration);
        candidateSlots.push({
          start: Math.max(searchStart, adjustedStart),
          end: Math.max(searchStart, adjustedStart) + duration,
          score: 0,
        });
      }
      searchStart = Math.max(searchStart, scheduled.end + BUFFER);
    }

    if (availSlot.end - searchStart >= duration) {
      const maxStart = availSlot.end - duration;
      const adjustedStart = Math.min(searchStart + offset, maxStart);
      candidateSlots.push({
        start: Math.max(searchStart, adjustedStart),
        end: Math.max(searchStart, adjustedStart) + duration,
        score: 0,
      });
    }
  }

  if (candidateSlots.length === 0) return null;

  for (const candidate of candidateSlots) {
    if (preference !== 'any') {
      const range = timeRanges[preference];
      if (candidate.start >= range.start && candidate.start < range.end) {
        candidate.score += 100;
      }
    }

    if (candidate.start < 7 * 60 && preference !== 'morning') {
      candidate.score -= 50;
    }

    const startMins = candidate.start % 60;
    if (startMins === 0 || startMins === 30) {
      candidate.score += 10;
    } else if (startMins === 15 || startMins === 45) {
      candidate.score += 5;
    }
  }

  candidateSlots.sort((a, b) => b.score - a.score);

  return { start: candidateSlots[0].start, end: candidateSlots[0].end };
}

/**
 * Smart scheduling with better spreading and user block support
 */
function generateSmartSchedule(
  goals: any[],
  availability: any,
  startOfWeek: Date,
  existingUserBlocks: any[] = []
): { blocks: any[]; warning: string | null } {
  const blocks: any[] = [];
  const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  let warning: string | null = null;

  const scheduledByDay: Record<string, Array<{ start: number; end: number; goalId: string }>> = {};
  DAYS.forEach((day) => {
    scheduledByDay[day] = [];
  });

  const userBlocksByDay: Record<string, Array<{ start: number; end: number }>> = {};
  DAYS.forEach((day) => {
    userBlocksByDay[day] = [];
  });

  existingUserBlocks.forEach((block) => {
    const blockDate = new Date(block.scheduled_start);
    const dayIndex = blockDate.getDay();
    const dayName = DAYS[dayIndex];
    
    const startMins = blockDate.getHours() * 60 + blockDate.getMinutes();
    const endMins = startMins + block.duration_mins;
    
    userBlocksByDay[dayName].push({
      start: startMins,
      end: endMins,
    });
    
    scheduledByDay[dayName].push({
      start: startMins,
      end: endMins,
      goalId: block.goal_id || 'user',
    });
  });

  console.log(`\nüì¶ User blocks by day:`);
  DAYS.forEach((day) => {
    if (userBlocksByDay[day].length > 0) {
      console.log(`   ${day}: ${userBlocksByDay[day].length} blocks`);
    }
  });

  const getGoalWeekNumber = (goal: any): number => {
    const createdAt = new Date(goal.created_at || new Date());
    const weeksSinceCreation = Math.floor(
      (startOfWeek.getTime() - createdAt.getTime()) / (7 * 24 * 60 * 60 * 1000)
    );
    return Math.max(1, weeksSinceCreation + 1);
  };

  interface PlannedSession {
    goalId: string;
    oderId: string;
    goalName: string;
    category: string;
    sessionName: string;
    sessionDuration: number;
    sessionDescription?: string;
    sessionTip?: string;
    preferredTime: 'morning' | 'afternoon' | 'evening' | 'any';
    scheduled: boolean;
  }

  const plannedSessions: PlannedSession[] = [];

  goals
    .filter((goal) => goal.plan && goal.plan.weekly_hours > 0)
    .forEach((goal) => {
      const currentWeek = getGoalWeekNumber(goal);
      
      const weeklyPlans = goal.plan?.weekly_plan?.weeks || goal.plan?.weekly_plans || [];
      
      let weekPlan = weeklyPlans.find((wp: any) => wp.week === currentWeek);
      if (!weekPlan && weeklyPlans.length > 0) {
        const weekIndex = (currentWeek - 1) % weeklyPlans.length;
        weekPlan = weeklyPlans[weekIndex];
      }

      let preferredTime: 'morning' | 'afternoon' | 'evening' | 'any' = 'any';
      if (goal.category === 'fitness' || goal.category === 'climbing') {
        preferredTime = availability.preferred_workout_time || 'morning';
      } else if (goal.category === 'business' || goal.category === 'career') {
        preferredTime = 'evening';
      } else if (goal.category === 'languages') {
        preferredTime = 'morning';
      }

      if (weekPlan && weekPlan.sessions && weekPlan.sessions.length > 0) {
        console.log(`   üìã ${goal.name} Week ${currentWeek}: ${weekPlan.sessions.length} specific sessions`);
        
        weekPlan.sessions.forEach((session: any) => {
          plannedSessions.push({
            goalId: goal.id,
            oderId: goal.user_id,
            goalName: goal.name,
            category: goal.category,
            sessionName: session.name || session.title || 'Training Session',
            sessionDuration: session.duration_mins || session.duration || 60,
            sessionDescription: session.description || session.focus || '',
            sessionTip: session.notes || session.tip || session.coach_tip || '',
            preferredTime,
            scheduled: false,
          });
        });
      } else {
        const weeklyHours = goal.plan?.weekly_hours || 5;
        const sessionsPerWeek = goal.plan?.sessions_per_week || Math.ceil(weeklyHours);
        const sessionDuration = Math.round((weeklyHours * 60) / sessionsPerWeek);
        
        console.log(`   ‚ö†Ô∏è ${goal.name}: No weekly_plans found, creating ${sessionsPerWeek} generic sessions`);
        
        for (let i = 0; i < sessionsPerWeek; i++) {
          plannedSessions.push({
            goalId: goal.id,
            oderId: goal.user_id,
            goalName: goal.name,
            category: goal.category,
            sessionName: `${goal.name} - Session ${i + 1}`,
            sessionDuration: Math.min(Math.max(sessionDuration, 15), 120),
            preferredTime,
            scheduled: false,
          });
        }
      }
    });

  plannedSessions.sort((a, b) => b.sessionDuration - a.sessionDuration);

  console.log(`\nüìä Sessions to schedule: ${plannedSessions.length} total`);
  plannedSessions.forEach((ps) => {
    console.log(`   ${ps.goalName}: "${ps.sessionName}" (${ps.sessionDuration}min) [${ps.preferredTime}]`);
  });

  const availableByDay: Record<string, Array<{ start: number; end: number }>> = {};
  DAYS.forEach((day) => {
    availableByDay[day] = getAvailableSlots(day, availability, userBlocksByDay[day]);
  });

  console.log(`\nüìÖ Available time per day:`);
  let totalAvailableMins = 0;
  DAYS.forEach((day) => {
    const totalMins = availableByDay[day].reduce((sum, slot) => sum + (slot.end - slot.start), 0);
    totalAvailableMins += totalMins;
    const hours = Math.round(totalMins / 60 * 10) / 10;
    console.log(`   ${day}: ${hours}h free`);
  });

  const totalNeededMins = plannedSessions.reduce((sum, ps) => sum + ps.sessionDuration, 0);
  if (totalNeededMins > totalAvailableMins * 0.8) {
    warning = `You need ${Math.round(totalNeededMins / 60)}h/week for all goals, but only have ~${Math.round(totalAvailableMins / 60)}h available. Some sessions may not fit.`;
    console.log(`\n‚ö†Ô∏è ${warning}`);
  }

  let globalSessionIndex = 0;
  
  const sessionsByGoal: Record<string, PlannedSession[]> = {};
  plannedSessions.forEach((ps) => {
    if (!sessionsByGoal[ps.goalId]) sessionsByGoal[ps.goalId] = [];
    sessionsByGoal[ps.goalId].push(ps);
  });

  let round = 0;
  const MAX_ROUNDS = 50;

  while (round < MAX_ROUNDS) {
    let anyScheduledThisRound = false;

    const dayOrder = [...DAYS];
    if (round > 0) {
      const rotateBy = round % 7;
      for (let i = 0; i < rotateBy; i++) {
        dayOrder.push(dayOrder.shift()!);
      }
    }

    for (const dayName of dayOrder) {
      const dayIndex = DAYS.indexOf(dayName);
      const currentDay = new Date(startOfWeek);
      currentDay.setDate(startOfWeek.getDate() + dayIndex);

      for (const goalId of Object.keys(sessionsByGoal)) {
        const goalSessions = sessionsByGoal[goalId];
        const nextSession = goalSessions.find((s) => !s.scheduled);
        
        if (!nextSession) continue;

        const sessionsThisDayForGoal = scheduledByDay[dayName].filter(
          (s) => s.goalId === goalId
        ).length;
        
        const maxPerDay = Math.max(Math.ceil(goalSessions.length / 5), 2);
        if (sessionsThisDayForGoal >= maxPerDay) continue;

        const slot = findBestSlot(
          availableByDay[dayName],
          scheduledByDay[dayName],
          nextSession.sessionDuration,
          nextSession.preferredTime,
          nextSession.goalId,
          globalSessionIndex
        );

        if (slot) {
          const scheduledTime = new Date(currentDay);
          const { hours, minutes } = fromMinutes(slot.start);
          scheduledTime.setHours(hours, minutes, 0, 0);

          const notesData = [
            nextSession.sessionName,
            nextSession.sessionDescription || '',
            nextSession.sessionTip || ''
          ].join('|||');

          blocks.push({
            user_id: nextSession.oderId,
            goal_id: nextSession.goalId,
            type: nextSession.category === 'fitness' || nextSession.category === 'climbing' ? 'workout' : 'training',
            scheduled_start: scheduledTime.toISOString(),
            duration_mins: nextSession.sessionDuration,
            status: 'scheduled',
            notes: notesData,
            created_by: 'auto',
            flexibility: 'movable',
          });

          scheduledByDay[dayName].push({
            start: slot.start,
            end: slot.end,
            goalId: nextSession.goalId,
          });

          nextSession.scheduled = true;
          globalSessionIndex++;
          anyScheduledThisRound = true;
        }
      }
    }

    round++;

    const allDone = plannedSessions.every((ps) => ps.scheduled);

    if (allDone) {
      console.log(`\n‚úÖ All ${plannedSessions.length} sessions scheduled after ${round} rounds`);
      break;
    }

    if (!anyScheduledThisRound) {
      console.log(`\n‚ö†Ô∏è No more slots available after ${round} rounds`);
      
      const unscheduled = plannedSessions.filter((ps) => !ps.scheduled);
      if (unscheduled.length > 0) {
        const details = unscheduled.slice(0, 3).map((ps) => 
          `"${ps.sessionName}" (${ps.sessionDuration}min)`
        ).join(', ');
        
        warning = `Couldn't fit ${unscheduled.length} sessions: ${details}${unscheduled.length > 3 ? '...' : ''}. Consider adjusting your schedule or reducing session count.`;
      }
      break;
    }
  }

  const scheduledCount = plannedSessions.filter((ps) => ps.scheduled).length;
  const totalHours = Math.round(blocks.reduce((sum, b) => sum + b.duration_mins, 0) / 60);
  console.log(`\n‚úÖ Generated ${blocks.length} sessions (${totalHours}h total)`);
  console.log(`   Scheduled: ${scheduledCount}/${plannedSessions.length} sessions`);

  return { blocks, warning };
}

// ============================================================
// ROUTES
// ============================================================

/**
 * GET /api/schedule
 * Get schedule blocks for a date range
 */
router.get('/', async (req: Request, res: Response) => {
  try {
    const { user_id, start_date, end_date } = req.query;

    if (!user_id) {
      return res.status(400).json({
        error: 'Missing user_id query parameter',
      });
    }

    let query = supabase
      .from('schedule_blocks')
      .select(
        `
        *,
        goals (name, category)
      `
      )
      .eq('user_id', user_id as string);

    if (start_date) {
      query = query.gte('scheduled_start', start_date as string);
    }

    if (end_date) {
      query = query.lte('scheduled_start', end_date as string);
    }

    const { data: blocks, error } = await query.order('scheduled_start', {
      ascending: true,
    });

    if (error) throw error;

    return res.json({
      blocks: blocks || [],
      count: blocks?.length || 0,
    });
  } catch (error: any) {
    console.error('‚ùå Schedule fetch error:', error);
    return res.status(500).json({
      error: 'Failed to fetch schedule',
      message: error.message,
    });
  }
});

/**
 * GET /api/schedule/today
 * Get today's schedule
 */
router.get('/today', async (req: Request, res: Response) => {
  try {
    const { user_id } = req.query;

    if (!user_id) {
      return res.status(400).json({
        error: 'Missing user_id query parameter',
      });
    }

    const today = new Date().toISOString().split('T')[0];

    const { data: blocks, error } = await supabase
      .from('schedule_blocks')
      .select(
        `
        *,
        goals (name, category)
      `
      )
      .eq('user_id', user_id as string)
      .gte('scheduled_start', `${today}T00:00:00`)
      .lt('scheduled_start', `${today}T23:59:59`)
      .order('scheduled_start', { ascending: true });

    if (error) throw error;

    return res.json({
      date: today,
      blocks: blocks || [],
      count: blocks?.length || 0,
    });
  } catch (error: any) {
    console.error('‚ùå Today schedule error:', error);
    return res.status(500).json({
      error: "Failed to fetch today's schedule",
      message: error.message,
    });
  }
});

/**
 * POST /api/schedule
 * Create a new schedule block
 */
router.post('/', async (req: Request, res: Response) => {
  try {
    const { user_id, goal_id, type, scheduled_start, duration_mins, notes } =
      req.body;

    if (!user_id || !type || !scheduled_start || !duration_mins) {
      return res.status(400).json({
        error: 'Missing required fields',
        required: ['user_id', 'type', 'scheduled_start', 'duration_mins'],
      });
    }

    const { data: block, error } = await supabase
      .from('schedule_blocks')
      .insert({
        user_id,
        goal_id: goal_id || null,
        type,
        scheduled_start,
        duration_mins,
        notes: notes || null,
        flexibility: 'movable',
        created_by: 'user',
        status: 'scheduled',
      })
      .select()
      .single();

    if (error) throw error;

    console.log(`‚úÖ Created schedule block: ${type} at ${scheduled_start}`);

    return res.json({
      block,
      message: 'Schedule block created',
    });
  } catch (error: any) {
    console.error('‚ùå Schedule creation error:', error);
    return res.status(500).json({
      error: 'Failed to create schedule block',
      message: error.message,
    });
  }
});

/**
 * POST /api/schedule/recurring
 * Create recurring blocks across multiple days for the entire calendar
 */
router.post('/recurring', async (req: Request, res: Response) => {
  try {
    const { user_id, type, days, start_time, end_time, notes } = req.body;

    if (!user_id || !type || !days || !Array.isArray(days) || days.length === 0 || !start_time || !end_time) {
      return res.status(400).json({
        error: 'Missing required fields',
        required: ['user_id', 'type', 'days (array)', 'start_time', 'end_time'],
        example: {
          user_id: 'uuid',
          type: 'work',
          days: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
          start_time: '09:00',
          end_time: '18:00',
          notes: 'Office work'
        }
      });
    }

    const [startHours, startMins] = start_time.split(':').map(Number);
    const [endHours, endMins] = end_time.split(':').map(Number);
    const durationMins = (endHours * 60 + endMins) - (startHours * 60 + startMins);

    if (durationMins <= 0) {
      return res.status(400).json({ error: 'End time must be after start time' });
    }

    console.log(`\nüìÖ ========== CREATING RECURRING BLOCKS ==========`);
    console.log(`üë§ User: ${user_id}`);
    console.log(`üìã Type: ${type}`);
    console.log(`üìÜ Days: ${days.join(', ')}`);
    console.log(`‚è∞ Time: ${start_time} - ${end_time} (${durationMins} mins)`);

    const { data: goals } = await supabase
      .from('goals')
      .select('target_date')
      .eq('user_id', user_id)
      .eq('status', 'active')
      .not('target_date', 'is', null)
      .order('target_date', { ascending: false })
      .limit(1);

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    let scheduleEndDate: Date;
    if (goals && goals.length > 0 && goals[0].target_date) {
      scheduleEndDate = new Date(goals[0].target_date);
      scheduleEndDate.setDate(scheduleEndDate.getDate() + 7);
    } else {
      scheduleEndDate = new Date(today);
      scheduleEndDate.setDate(scheduleEndDate.getDate() + 12 * 7);
    }

    console.log(`üìÜ Scheduling from ${today.toDateString()} to ${scheduleEndDate.toDateString()}`);

    const DAYS_MAP: Record<string, number> = {
      'sunday': 0,
      'monday': 1,
      'tuesday': 2,
      'wednesday': 3,
      'thursday': 4,
      'friday': 5,
      'saturday': 6,
    };

    const targetDayIndices = days
      .map((d: string) => DAYS_MAP[d.toLowerCase()])
      .filter((d: number | undefined) => d !== undefined);

    if (targetDayIndices.length === 0) {
      return res.status(400).json({ error: 'Invalid day names provided' });
    }

    const blocksToCreate: any[] = [];
    const currentDate = new Date(today);

    while (currentDate <= scheduleEndDate) {
      const dayIndex = currentDate.getDay();
      
      if (targetDayIndices.includes(dayIndex)) {
        const scheduledStart = new Date(currentDate);
        scheduledStart.setHours(startHours, startMins, 0, 0);

        blocksToCreate.push({
          user_id,
          goal_id: null,
          type,
          scheduled_start: scheduledStart.toISOString(),
          duration_mins: durationMins,
          notes: notes || null,
          flexibility: 'fixed',
          created_by: 'user',
          status: 'scheduled',
        });
      }

      currentDate.setDate(currentDate.getDate() + 1);
    }

    console.log(`üì¶ Creating ${blocksToCreate.length} blocks...`);

    for (const block of blocksToCreate) {
      await supabase
        .from('schedule_blocks')
        .delete()
        .eq('user_id', user_id)
        .eq('type', type)
        .eq('scheduled_start', block.scheduled_start)
        .eq('created_by', 'user');
    }

    const BATCH_SIZE = 100;
    let insertedCount = 0;

    for (let i = 0; i < blocksToCreate.length; i += BATCH_SIZE) {
      const batch = blocksToCreate.slice(i, i + BATCH_SIZE);
      const { error: insertError } = await supabase
        .from('schedule_blocks')
        .insert(batch);

      if (insertError) {
        console.error('Batch insert error:', insertError);
        throw insertError;
      }
      insertedCount += batch.length;
    }

    console.log(`‚úÖ Created ${insertedCount} recurring blocks`);

    return res.json({
      success: true,
      blocksCreated: insertedCount,
      type,
      days,
      time: `${start_time} - ${end_time}`,
      duration_mins: durationMins,
      schedule_until: scheduleEndDate.toISOString().split('T')[0],
      message: `Created ${insertedCount} ${type} blocks for ${days.join(', ')} from ${start_time} to ${end_time}`,
    });

  } catch (error: any) {
    console.error('‚ùå Recurring block creation error:', error);
    return res.status(500).json({
      error: 'Failed to create recurring blocks',
      message: error.message,
    });
  }
});

/**
 * Generate schedule for a SINGLE GOAL for its ENTIRE DURATION
 */
async function generateFullGoalSchedule(
  goal: any,
  userId: string,
  preferredDays: string[] = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
  preferredTime: 'morning' | 'afternoon' | 'evening' | 'any' = 'any'
): Promise<{ blocksCreated: number; warning: string | null }> {
  console.log(`\nüóìÔ∏è ========== GENERATING FULL SCHEDULE FOR GOAL ==========`);
  console.log(`üìã Goal: ${goal.name}`);
  console.log(`üìÖ Preferred days: ${preferredDays.join(', ')}`);
  console.log(`‚è∞ Preferred time: ${preferredTime}`);

  const plan = goal.plan;
  if (!plan || !plan.weekly_hours || plan.weekly_hours <= 0) {
    console.log('‚ö†Ô∏è No valid plan found');
    return { blocksCreated: 0, warning: 'No valid training plan' };
  }

  const startDate = new Date();
  startDate.setHours(0, 0, 0, 0);
  
  let endDate: Date;
  if (goal.target_date) {
    endDate = new Date(goal.target_date);
  } else {
    const totalWeeks = plan.total_weeks || Math.ceil((plan.total_estimated_hours || 50) / plan.weekly_hours);
    endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + totalWeeks * 7);
  }

  const totalWeeks = Math.ceil((endDate.getTime() - startDate.getTime()) / (7 * 24 * 60 * 60 * 1000));
  console.log(`üìÜ Duration: ${totalWeeks} weeks (${startDate.toDateString()} ‚Üí ${endDate.toDateString()})`);

  const { data: availability } = await supabase
    .from('user_availability')
    .select('*')
    .eq('user_id', userId)
    .single();

  const effectiveAvailability = availability || {
    wake_time: '06:00',
    sleep_time: '22:00',
    work_schedule: {},
    fixed_commitments: [],
    daily_commute_mins: 0,
    preferred_workout_time: preferredTime,
  };

  const { data: existingUserBlocks } = await supabase
    .from('schedule_blocks')
    .select('*')
    .eq('user_id', userId)
    .gte('scheduled_start', startDate.toISOString())
    .lt('scheduled_start', endDate.toISOString())
    .or('created_by.eq.user,type.in.(work,commute,event,social)');

  console.log(`üì¶ Existing blocks to schedule around: ${existingUserBlocks?.length || 0}`);

  await supabase
    .from('schedule_blocks')
    .delete()
    .eq('user_id', userId)
    .eq('goal_id', goal.id)
    .eq('created_by', 'auto');

  const weeklyPlan = plan.weekly_plan;
  const allBlocks: any[] = [];
  let warning: string | null = null;

  const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  const sessionsPerWeek = plan.sessions_per_week || 3;

  for (let weekNum = 0; weekNum < totalWeeks; weekNum++) {
    const weekStart = new Date(startDate);
    weekStart.setDate(startDate.getDate() + weekNum * 7);

    let weekSessions: any[] = [];
    
    if (weeklyPlan?.weeks && weeklyPlan.weeks[weekNum]) {
      weekSessions = weeklyPlan.weeks[weekNum].sessions || [];
    } else if (weeklyPlan?.weeks && weeklyPlan.weeks.length > 0) {
      const cycleIndex = weekNum % weeklyPlan.weeks.length;
      weekSessions = weeklyPlan.weeks[cycleIndex]?.sessions || [];
    } else {
      const sessionDuration = Math.round((plan.weekly_hours * 60) / sessionsPerWeek);
      for (let i = 0; i < sessionsPerWeek; i++) {
        weekSessions.push({
          name: `${goal.name} Session`,
          duration_mins: sessionDuration,
          description: `Training session ${i + 1}`,
        });
      }
    }

    const scheduledThisWeek: Array<{ day: string; start: number; end: number }> = [];

    const userBlocksByDay: Record<string, Array<{ start: number; end: number }>> = {};
    DAYS.forEach(day => { userBlocksByDay[day] = []; });

    (existingUserBlocks || []).forEach((block: any) => {
      const blockDate = new Date(block.scheduled_start);
      const blockWeekStart = new Date(blockDate);
      blockWeekStart.setDate(blockDate.getDate() - blockDate.getDay());
      blockWeekStart.setHours(0, 0, 0, 0);

      if (blockWeekStart.getTime() === weekStart.getTime()) {
        const dayName = DAYS[blockDate.getDay()];
        const startMins = blockDate.getHours() * 60 + blockDate.getMinutes();
        userBlocksByDay[dayName].push({
          start: startMins,
          end: startMins + (block.duration_mins || 60),
        });
      }
    });

    let sessionIndex = 0;
    for (const session of weekSessions) {
      const duration = session.duration_mins || 60;
      let scheduled = false;

      for (const dayName of preferredDays) {
        if (scheduled) break;
        
        const dayIndex = DAYS.indexOf(dayName.toLowerCase());
        if (dayIndex === -1) continue;

        const dayDate = new Date(weekStart);
        dayDate.setDate(weekStart.getDate() + dayIndex);

        if (dayDate < new Date()) continue;

        const availSlots = getAvailableSlots(dayName, effectiveAvailability, userBlocksByDay[dayName]);

        for (const slot of availSlots) {
          if (scheduled) break;
          
          if (slot.end - slot.start < duration) continue;

          const todayScheduled = scheduledThisWeek.filter(s => s.day === dayName);
          let hasConflict = false;

          const candidateStart = slot.start;
          const candidateEnd = candidateStart + duration;

          for (const existing of todayScheduled) {
            if (candidateStart < existing.end + 15 && candidateEnd > existing.start - 15) {
              hasConflict = true;
              break;
            }
          }

          if (!hasConflict) {
            const scheduledTime = new Date(dayDate);
            scheduledTime.setHours(Math.floor(candidateStart / 60), candidateStart % 60, 0, 0);

            allBlocks.push({
              user_id: userId,
              goal_id: goal.id,
              type: goal.category === 'fitness' || goal.category === 'climbing' ? 'workout' : 'training',
              scheduled_start: scheduledTime.toISOString(),
              duration_mins: duration,
              status: 'scheduled',
              notes: [session.name, session.description || '', session.tip || ''].join('|||'),
              created_by: 'auto',
              flexibility: 'movable',
            });

            scheduledThisWeek.push({ day: dayName, start: candidateStart, end: candidateEnd });
            scheduled = true;
          }
        }
      }

      if (!scheduled) {
        for (const dayName of DAYS) {
          if (scheduled) break;
          if (preferredDays.map(d => d.toLowerCase()).includes(dayName)) continue;

          const dayIndex = DAYS.indexOf(dayName);
          const dayDate = new Date(weekStart);
          dayDate.setDate(weekStart.getDate() + dayIndex);

          if (dayDate < new Date()) continue;

          const availSlots = getAvailableSlots(dayName, effectiveAvailability, userBlocksByDay[dayName]);

          for (const slot of availSlots) {
            if (scheduled) break;
            if (slot.end - slot.start < duration) continue;

            const todayScheduled = scheduledThisWeek.filter(s => s.day === dayName);
            let hasConflict = false;
            const candidateStart = slot.start;
            const candidateEnd = candidateStart + duration;

            for (const existing of todayScheduled) {
              if (candidateStart < existing.end + 15 && candidateEnd > existing.start - 15) {
                hasConflict = true;
                break;
              }
            }

            if (!hasConflict) {
              const scheduledTime = new Date(dayDate);
              scheduledTime.setHours(Math.floor(candidateStart / 60), candidateStart % 60, 0, 0);

              allBlocks.push({
                user_id: userId,
                goal_id: goal.id,
                type: goal.category === 'fitness' || goal.category === 'climbing' ? 'workout' : 'training',
                scheduled_start: scheduledTime.toISOString(),
                duration_mins: duration,
                status: 'scheduled',
                notes: [session.name, session.description || '', session.tip || ''].join('|||'),
                created_by: 'auto',
                flexibility: 'movable',
              });

              scheduledThisWeek.push({ day: dayName, start: candidateStart, end: candidateEnd });
              scheduled = true;
            }
          }
        }
      }

      if (!scheduled) {
        warning = `Some sessions couldn't be scheduled. Consider adjusting your availability or reducing weekly hours.`;
      }

      sessionIndex++;
    }
  }

  if (allBlocks.length > 0) {
    const BATCH_SIZE = 100;
    for (let i = 0; i < allBlocks.length; i += BATCH_SIZE) {
      const batch = allBlocks.slice(i, i + BATCH_SIZE);
      const { error: insertError } = await supabase
        .from('schedule_blocks')
        .insert(batch);

      if (insertError) {
        console.error('Insert batch error:', insertError);
        throw insertError;
      }
    }
  }

  console.log(`‚úÖ Created ${allBlocks.length} schedule blocks for ${totalWeeks} weeks`);

  return { blocksCreated: allBlocks.length, warning };
}

/**
 * POST /api/schedule/generate-for-goal
 * Generate full schedule for a specific goal
 */
router.post('/generate-for-goal', async (req: Request, res: Response) => {
  try {
    const { user_id, goal_id, preferred_days, preferred_time } = req.body;

    if (!user_id || !goal_id) {
      return res.status(400).json({ error: 'Missing user_id or goal_id' });
    }

    const { data: goal, error: goalError } = await supabase
      .from('goals')
      .select('*')
      .eq('id', goal_id)
      .single();

    if (goalError || !goal) {
      return res.status(404).json({ error: 'Goal not found' });
    }

    const result = await generateFullGoalSchedule(
      goal,
      user_id,
      preferred_days || ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
      preferred_time || 'any'
    );

    return res.json({
      success: true,
      ...result,
      message: `Generated ${result.blocksCreated} sessions for "${goal.name}"`,
    });

  } catch (error: any) {
    console.error('‚ùå Generate for goal error:', error);
    return res.status(500).json({
      error: 'Failed to generate schedule',
      message: error.message,
    });
  }
});

/**
 * POST /api/schedule/auto-generate
 * Auto-generate weekly schedule based on goals and availability
 */
router.post('/auto-generate', async (req: Request, res: Response) => {
  try {
    const { user_id } = req.body;

    if (!user_id) {
      return res.status(400).json({ error: 'Missing user_id' });
    }

    console.log(`\nü§ñ ========== AUTO-GENERATE SCHEDULE ==========`);
    console.log(`ü§ñ User: ${user_id}`);

    const { data: goals, error: goalsError } = await supabase
      .from('goals')
      .select('*')
      .eq('user_id', user_id)
      .eq('status', 'active');

    if (goalsError) throw goalsError;

    const goalsWithPlans = (goals || []).filter(
      (g) => g.plan && g.plan.weekly_hours && g.plan.weekly_hours > 0
    );

    console.log(`üìã Active goals: ${goals?.length || 0}`);
    console.log(`üìã Goals with plans (weekly_hours > 0): ${goalsWithPlans.length}`);

    if (goalsWithPlans.length === 0) {
      return res.status(400).json({
        error: 'No active goals with training plans found',
        message: 'Please create goals and generate training plans with weekly_hours > 0',
      });
    }

    const { data: availability } = await supabase
      .from('user_availability')
      .select('*')
      .eq('user_id', user_id)
      .single();

    const effectiveAvailability = availability || {
      wake_time: '06:00',
      sleep_time: '22:00',
      work_schedule: {},
      fixed_commitments: [],
      daily_commute_mins: 0,
      preferred_workout_time: 'morning',
    };

    console.log(`üìÖ Availability: ${availability ? 'Custom set' : 'Using defaults (6am-10pm)'}`);

    const today = new Date();
    const startOfWeek = new Date(today);
    startOfWeek.setDate(today.getDate() - today.getDay());
    startOfWeek.setHours(0, 0, 0, 0);

    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 7);

    const { data: existingUserBlocks } = await supabase
      .from('schedule_blocks')
      .select('*')
      .eq('user_id', user_id)
      .gte('scheduled_start', startOfWeek.toISOString())
      .lt('scheduled_start', endOfWeek.toISOString())
      .or('created_by.eq.user,type.in.(work,commute,event,social)');

    console.log(`üì¶ Existing user blocks to schedule around: ${existingUserBlocks?.length || 0}`);

    await supabase
      .from('schedule_blocks')
      .delete()
      .eq('user_id', user_id)
      .eq('created_by', 'auto')
      .gte('scheduled_start', startOfWeek.toISOString())
      .lt('scheduled_start', endOfWeek.toISOString());

    const { blocks: schedule, warning } = generateSmartSchedule(
      goalsWithPlans, 
      effectiveAvailability, 
      startOfWeek,
      existingUserBlocks || []
    );

    if (schedule.length > 0) {
      const { error: insertError } = await supabase
        .from('schedule_blocks')
        .insert(schedule);

      if (insertError) throw insertError;
    }

    const totalHours = Math.round(schedule.reduce((sum, b) => sum + b.duration_mins, 0) / 60);
    console.log(`\n‚úÖ SUCCESS: ${schedule.length} sessions, ${totalHours}h total`);

    return res.json({
      success: true,
      schedule,
      warning,
      stats: {
        sessions: schedule.length,
        totalHours,
        goalsScheduled: goalsWithPlans.length,
      },
      message: `Generated ${schedule.length} training sessions (${totalHours}h) for ${goalsWithPlans.length} goals`,
    });
  } catch (error: any) {
    console.error('‚ùå Auto-schedule generation error:', error);
    return res.status(500).json({
      error: 'Failed to generate schedule',
      message: error.message,
    });
  }
});

// ============================================================
// NEW ENDPOINTS - Complete with notes, Skip, Smart Reschedule
// ============================================================

/**
 * PATCH /api/schedule/:id/complete-with-notes
 * Complete a block with just notes (simplified - no metrics)
 */
router.patch('/:id/complete-with-notes', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { notes } = req.body;

    console.log(`‚úÖ Completing block ${id} with notes`);

    const { data: block, error } = await supabase
      .from('schedule_blocks')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        notes: notes || null,
      })
      .eq('id', id)
      .select(`
        *,
        goals (id, name, category, plan, target_date)
      `)
      .single();

    if (error) throw error;

    let progressMessage = null;
    if (block.goal_id) {
      const progress = await calculateGoalProgress(block.goal_id);
      if (progress) {
        progressMessage = progress.message;
      }
    }

    return res.json({
      success: true,
      block,
      message: progressMessage || 'Session logged!',
    });

  } catch (error: any) {
    console.error('‚ùå Complete with notes error:', error);
    return res.status(500).json({
      error: 'Failed to complete block',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/skip
 * Skip a block - marks as skipped, calculates deadline impact
 */
router.patch('/:id/skip', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    console.log(`‚è≠Ô∏è Skipping block ${id}`);

    const { data: block, error: fetchError } = await supabase
      .from('schedule_blocks')
      .select(`
        *,
        goals (id, name, target_date, plan)
      `)
      .eq('id', id)
      .single();

    if (fetchError || !block) {
      return res.status(404).json({ error: 'Block not found' });
    }

    const { error: updateError } = await supabase
      .from('schedule_blocks')
      .update({
        status: 'skipped',
      })
      .eq('id', id);

    if (updateError) throw updateError;

    let deadlineImpact = null;
    if (block.goal_id && block.goals?.target_date) {
      const scheduledDate = new Date(block.scheduled_start);
      const today = new Date();
      const daysDiff = Math.floor((scheduledDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysDiff > 7) {
        const sessionsPerWeek = block.goals.plan?.sessions_per_week || 3;
        const daysImpact = Math.ceil(7 / sessionsPerWeek);
        
        deadlineImpact = `Goal pushed back ~${daysImpact} days.`;
        
        const currentTarget = new Date(block.goals.target_date);
        currentTarget.setDate(currentTarget.getDate() + daysImpact);
        
        await supabase
          .from('goals')
          .update({ target_date: currentTarget.toISOString().split('T')[0] })
          .eq('id', block.goal_id);
      }
    }

    return res.json({
      success: true,
      deadline_impact: deadlineImpact,
      message: deadlineImpact || 'Session skipped',
    });

  } catch (error: any) {
    console.error('‚ùå Skip error:', error);
    return res.status(500).json({
      error: 'Failed to skip block',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/reschedule-smart
 * Smart reschedule - later today, tomorrow, or custom time
 */
router.patch('/:id/reschedule-smart', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { option, custom_time } = req.body;

    console.log(`üìÖ Smart reschedule block ${id} to ${option}`);

    const { data: block, error: fetchError } = await supabase
      .from('schedule_blocks')
      .select('*')
      .eq('id', id)
      .single();

    if (fetchError || !block) {
      return res.status(404).json({ error: 'Block not found' });
    }

    let newStart: Date;
    const now = new Date();

    if (option === 'later_today') {
      newStart = new Date(now);
      newStart.setHours(Math.max(now.getHours() + 2, 18), 0, 0, 0);
      
      if (newStart.getHours() >= 22) {
        newStart.setDate(newStart.getDate() + 1);
        newStart.setHours(8, 0, 0, 0);
      }
    } else if (option === 'tomorrow') {
      const originalTime = new Date(block.scheduled_start);
      newStart = new Date(now);
      newStart.setDate(newStart.getDate() + 1);
      newStart.setHours(originalTime.getHours(), originalTime.getMinutes(), 0, 0);
    } else if (option === 'custom' && custom_time) {
      newStart = new Date(custom_time);
    } else {
      return res.status(400).json({ error: 'Invalid reschedule option' });
    }

    const originalStart = block.original_scheduled_start || block.scheduled_start;

    const { data: updated, error: updateError } = await supabase
      .from('schedule_blocks')
      .update({
        scheduled_start: newStart.toISOString(),
        original_scheduled_start: originalStart,
        status: 'scheduled',
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) throw updateError;

    return res.json({
      success: true,
      block: updated,
      new_time: newStart.toISOString(),
      message: `Rescheduled to ${newStart.toLocaleString('en-GB', { 
        weekday: 'short', 
        hour: '2-digit', 
        minute: '2-digit' 
      })}`,
    });

  } catch (error: any) {
    console.error('‚ùå Smart reschedule error:', error);
    return res.status(500).json({
      error: 'Failed to reschedule block',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/push-to-next-week
 * Push a session to next week - affects goal deadline
 */
router.patch('/:id/push-to-next-week', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    console.log(`üìÖ Pushing block ${id} to next week`);

    const { data: block, error: fetchError } = await supabase
      .from('schedule_blocks')
      .select(`
        *,
        goals (id, name, target_date, plan)
      `)
      .eq('id', id)
      .single();

    if (fetchError || !block) {
      return res.status(404).json({ error: 'Block not found' });
    }

    // Calculate new date (same day next week)
    const currentDate = new Date(block.scheduled_start);
    const newDate = new Date(currentDate);
    newDate.setDate(currentDate.getDate() + 7);

    // Store original start if not set
    const originalStart = block.original_scheduled_start || block.scheduled_start;

    // Update the block
    const { data: updated, error: updateError } = await supabase
      .from('schedule_blocks')
      .update({
        scheduled_start: newDate.toISOString(),
        original_scheduled_start: originalStart,
        status: 'scheduled',
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) throw updateError;

    // Calculate deadline impact
    let deadlineImpact: string | null = null;
    if (block.goal_id && block.goals?.target_date) {
      const sessionsPerWeek = block.goals.plan?.sessions_per_week || 3;
      const daysImpact = Math.ceil(7 / sessionsPerWeek);
      
      // Update goal target date
      const currentTarget = new Date(block.goals.target_date);
      currentTarget.setDate(currentTarget.getDate() + daysImpact);
      
      await supabase
        .from('goals')
        .update({ target_date: currentTarget.toISOString().split('T')[0] })
        .eq('id', block.goal_id);

      deadlineImpact = `Goal deadline pushed to ${currentTarget.toLocaleDateString('en-GB', { 
        day: 'numeric', 
        month: 'short' 
      })} (+${daysImpact} days)`;
    }

    return res.json({
      success: true,
      block: updated,
      new_date: newDate.toISOString(),
      deadline_impact: deadlineImpact,
      message: `Moved to ${newDate.toLocaleDateString('en-GB', { 
        weekday: 'short', 
        day: 'numeric', 
        month: 'short' 
      })}`,
    });

  } catch (error: any) {
    console.error('‚ùå Push to next week error:', error);
    return res.status(500).json({
      error: 'Failed to push block',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/complete-early
 * Complete a future session early - can pull deadline forward
 */
router.patch('/:id/complete-early', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { notes } = req.body;

    console.log(`‚úÖ Completing block ${id} early`);

    const { data: block, error: fetchError } = await supabase
      .from('schedule_blocks')
      .select(`
        *,
        goals (id, name, target_date, plan)
      `)
      .eq('id', id)
      .single();

    if (fetchError || !block) {
      return res.status(404).json({ error: 'Block not found' });
    }

    // Mark as completed
    const { data: updated, error: updateError } = await supabase
      .from('schedule_blocks')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        notes: notes || null,
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) throw updateError;

    // Check if completing early - session was scheduled for the future
    let deadlineImpact: string | null = null;
    const scheduledDate = new Date(block.scheduled_start);
    const now = new Date();
    
    if (scheduledDate > now && block.goal_id && block.goals?.target_date) {
      // Calculate days ahead
      const daysAhead = Math.floor((scheduledDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysAhead >= 1) {
        // Pull deadline forward
        const currentTarget = new Date(block.goals.target_date);
        currentTarget.setDate(currentTarget.getDate() - daysAhead);
        
        await supabase
          .from('goals')
          .update({ target_date: currentTarget.toISOString().split('T')[0] })
          .eq('id', block.goal_id);

        deadlineImpact = `Completed ${daysAhead} day${daysAhead > 1 ? 's' : ''} early! Deadline pulled to ${currentTarget.toLocaleDateString('en-GB', { 
          day: 'numeric', 
          month: 'short' 
        })} üî•`;
      }
    }

    // Calculate progress
    let progressMessage = 'Session logged!';
    if (block.goal_id) {
      const progress = await calculateGoalProgress(block.goal_id);
      if (progress) {
        progressMessage = progress.message;
      }
    }

    return res.json({
      success: true,
      block: updated,
      deadline_impact: deadlineImpact,
      message: deadlineImpact || progressMessage,
    });

  } catch (error: any) {
    console.error('‚ùå Complete early error:', error);
    return res.status(500).json({
      error: 'Failed to complete block',
      message: error.message,
    });
  }
});

// ============================================================
// EXISTING ENDPOINTS (unchanged)
// ============================================================

/**
 * PATCH /api/schedule/:id
 * Update a schedule block (for drag-and-drop)
 */
router.patch('/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { scheduled_start, duration_mins, notes } = req.body;

    const updateData: any = {};
    if (scheduled_start) updateData.scheduled_start = scheduled_start;
    if (duration_mins) updateData.duration_mins = duration_mins;
    if (notes !== undefined) updateData.notes = notes;

    if (Object.keys(updateData).length === 0) {
      return res.status(400).json({
        error: 'No update data provided',
      });
    }

    const { data: block, error } = await supabase
      .from('schedule_blocks')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    console.log(`‚úÖ Updated schedule block: ${id}`);

    return res.json({
      block,
      message: 'Schedule block updated',
    });
  } catch (error: any) {
    console.error('‚ùå Update error:', error);
    return res.status(500).json({
      error: 'Failed to update block',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/with-future
 * Update a schedule block and optionally apply the same time change to all future matching sessions
 */
router.patch('/:id/with-future', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { scheduled_start, apply_to_future } = req.body;

    if (!scheduled_start) {
      return res.status(400).json({ error: 'scheduled_start is required' });
    }

    const { data: originalBlock, error: fetchError } = await supabase
      .from('schedule_blocks')
      .select('*, goals(name, category)')
      .eq('id', id)
      .single();

    if (fetchError || !originalBlock) {
      return res.status(404).json({ error: 'Block not found' });
    }

    const { data: updatedBlock, error: updateError } = await supabase
      .from('schedule_blocks')
      .update({ scheduled_start })
      .eq('id', id)
      .select()
      .single();

    if (updateError) throw updateError;

    let updatedCount = 1;

    if (apply_to_future && originalBlock.goal_id && originalBlock.notes) {
      const originalDate = new Date(originalBlock.scheduled_start);
      const newDate = new Date(scheduled_start);
      
      const sessionName = originalBlock.notes.split('|||')[0];
      
      const newDayOfWeek = newDate.getDay();
      const newHour = newDate.getHours();
      const newMinute = newDate.getMinutes();
      
      console.log(`üîÑ Applying to future sessions: "${sessionName}" -> ${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][newDayOfWeek]} ${newHour}:${String(newMinute).padStart(2, '0')}`);
      
      const { data: futureBlocks, error: futureError } = await supabase
        .from('schedule_blocks')
        .select('id, scheduled_start, notes')
        .eq('goal_id', originalBlock.goal_id)
        .gt('scheduled_start', originalBlock.scheduled_start)
        .neq('id', id)
        .eq('status', 'scheduled');

      if (futureError) throw futureError;

      const matchingBlocks = (futureBlocks || []).filter(block => {
        const blockSessionName = (block.notes || '').split('|||')[0];
        return blockSessionName === sessionName;
      });

      console.log(`üì¶ Found ${matchingBlocks.length} future matching sessions`);

      for (const block of matchingBlocks) {
        const blockDate = new Date(block.scheduled_start);
        
        const currentDayOfWeek = blockDate.getDay();
        let daysDiff = newDayOfWeek - currentDayOfWeek;
        if (daysDiff < 0) daysDiff += 7;
        if (daysDiff === 0) daysDiff = 0;
        
        const newBlockDate = new Date(blockDate);
        newBlockDate.setDate(blockDate.getDate() + daysDiff);
        newBlockDate.setHours(newHour, newMinute, 0, 0);

        const { error: blockUpdateError } = await supabase
          .from('schedule_blocks')
          .update({ scheduled_start: newBlockDate.toISOString() })
          .eq('id', block.id);

        if (!blockUpdateError) {
          updatedCount++;
        }
      }

      console.log(`‚úÖ Updated ${updatedCount} sessions total (1 current + ${matchingBlocks.length} future)`);
    }

    return res.json({
      block: updatedBlock,
      updatedCount,
      message: apply_to_future 
        ? `Updated ${updatedCount} sessions` 
        : 'Session moved',
    });
  } catch (error: any) {
    console.error('‚ùå Update with future error:', error);
    return res.status(500).json({
      error: 'Failed to update sessions',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/reschedule
 * Reschedule a block (legacy endpoint)
 */
router.patch('/:id/reschedule', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { new_start_time } = req.body;

    if (!new_start_time) {
      return res.status(400).json({
        error: 'Missing new_start_time',
      });
    }

    const newDate = new Date(new_start_time);
    const block = await rescheduleBlock(id, newDate);

    return res.json({
      block,
      message: 'Block rescheduled successfully',
    });
  } catch (error: any) {
    console.error('‚ùå Reschedule error:', error);
    return res.status(500).json({
      error: 'Failed to reschedule block',
      message: error.message,
    });
  }
});

/**
 * DELETE /api/schedule/:id
 * Delete a schedule block
 */
router.delete('/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const { error } = await supabase.from('schedule_blocks').delete().eq('id', id);

    if (error) throw error;

    console.log(`üóëÔ∏è Deleted schedule block: ${id}`);

    return res.json({
      message: 'Schedule block deleted',
    });
  } catch (error: any) {
    console.error('‚ùå Delete error:', error);
    return res.status(500).json({
      error: 'Failed to delete block',
      message: error.message,
    });
  }
});

/**
 * PATCH /api/schedule/:id/complete
 * Mark a block as completed (legacy - no notes)
 */
router.patch('/:id/complete', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const { data: block, error } = await supabase
      .from('schedule_blocks')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
      })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    console.log(`‚úÖ Marked block complete: ${id}`);

    return res.json({
      block,
      message: 'Block marked as completed',
    });
  } catch (error: any) {
    console.error('‚ùå Complete error:', error);
    return res.status(500).json({
      error: 'Failed to mark block complete',
      message: error.message,
    });
  }
});

export default router;
--- ai-chat.ts ---
import { Router, Request, Response } from 'express';
import { supabase } from '../services/supabase';
import { openai } from '../services/openai';

const router = Router();

// Tool definitions for OpenAI function calling
const tools: any[] = [
  {
    type: 'function',
    function: {
      name: 'propose_action',
      description: 'Propose an action to the user and ask for confirmation. ALWAYS use this before making any changes. Never execute actions directly - always propose first.',
      parameters: {
        type: 'object',
        properties: {
          action_type: { 
            type: 'string', 
            enum: ['create_event', 'delete_block', 'reschedule_session', 'complete_session', 'skip_session'],
            description: 'The type of action being proposed' 
          },
          description: { type: 'string', description: 'Human-readable description of what will happen' },
          details: { type: 'object', description: 'The parameters that will be used for the action' },
          conflicts: { 
            type: 'array', 
            items: { 
              type: 'object',
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                time: { type: 'string' }
              }
            },
            description: 'Any conflicting blocks that would need to be deleted' 
          },
        },
        required: ['action_type', 'description', 'details'],
      },
    },
  },
  {
    type: 'function',
    function: {
      name: 'execute_confirmed_action',
      description: 'Execute an action that the user has EXPLICITLY confirmed. Only use after user says "yes", "confirm", "do it", "go ahead", etc.',
      parameters: {
        type: 'object',
        properties: {
          action_type: { 
            type: 'string', 
            enum: ['create_event', 'delete_block', 'reschedule_session', 'complete_session', 'skip_session'],
            description: 'The type of action to execute' 
          },
          params: { type: 'object', description: 'The parameters for the action' },
        },
        required: ['action_type', 'params'],
      },
    },
  },
  {
    type: 'function',
    function: {
      name: 'get_upcoming_tasks',
      description: 'Get upcoming tasks from the next few days that the user could do NOW to get ahead. Use this when user asks "what can I do now?", "anything I can work on?", "want to be productive", etc.',
      parameters: {
        type: 'object',
        properties: {
          days_ahead: { type: 'number', description: 'How many days ahead to look (default 3)' },
        },
        required: [],
      },
    },
  },
  {
    type: 'function',
    function: {
      name: 'find_best_reschedule_time',
      description: 'Find the best available time slot to reschedule a session. Use this to check availability before proposing a reschedule.',
      parameters: {
        type: 'object',
        properties: {
          session_id: { type: 'string', description: 'The ID of the session to reschedule' },
          target_date: { type: 'string', description: 'The date to check for availability in YYYY-MM-DD format' },
        },
        required: ['session_id', 'target_date'],
      },
    },
  },
  {
    type: 'function',
    function: {
      name: 'get_schedule',
      description: 'Get the user\'s schedule for a specific date.',
      parameters: {
        type: 'object',
        properties: {
          date: { type: 'string', description: 'Date in YYYY-MM-DD format, or "today", "tomorrow", "this_week"' },
        },
        required: ['date'],
      },
    },
  },
  {
    type: 'function',
    function: {
      name: 'check_conflicts',
      description: 'Check if a time slot has any conflicts and return details of conflicting blocks.',
      parameters: {
        type: 'object',
        properties: {
          date: { type: 'string', description: 'Date in YYYY-MM-DD format' },
          start_time: { type: 'string', description: 'Start time in HH:MM format' },
          end_time: { type: 'string', description: 'End time in HH:MM format' },
        },
        required: ['date', 'start_time', 'end_time'],
      },
    },
  },
];

// ============================================================
// TOOL EXECUTION FUNCTIONS
// ============================================================

async function executeGetUpcomingTasks(
  userId: string,
  params: { days_ahead?: number }
): Promise<string> {
  try {
    const daysAhead = params.days_ahead || 3;
    const now = new Date();
    const todayEnd = new Date(now);
    todayEnd.setHours(23, 59, 59, 999);
    
    const futureEnd = new Date(now);
    futureEnd.setDate(futureEnd.getDate() + daysAhead);
    futureEnd.setHours(23, 59, 59, 999);
    
    const { data: blocks, error } = await supabase
      .from('schedule_blocks')
      .select('*, goals(name, category)')
      .eq('user_id', userId)
      .eq('status', 'scheduled')
      .gt('scheduled_start', now.toISOString())
      .lte('scheduled_start', futureEnd.toISOString())
      .order('scheduled_start', { ascending: true })
      .limit(10);
    
    if (error) throw error;
    
    if (!blocks || blocks.length === 0) {
      return JSON.stringify({
        success: true,
        message: "No upcoming tasks in the next few days. You're all caught up!",
        tasks: [],
      });
    }
    
    const tasks = blocks.map(b => {
      const scheduledDate = new Date(b.scheduled_start);
      const isToday = scheduledDate.toDateString() === now.toDateString();
      const isTomorrow = scheduledDate.toDateString() === new Date(now.getTime() + 86400000).toDateString();
      
      let dayLabel = scheduledDate.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
      if (isToday) dayLabel = 'Today';
      if (isTomorrow) dayLabel = 'Tomorrow';
      
      return {
        id: b.id,
        name: b.notes?.split('|||')[0] || b.goals?.name || b.type,
        goal: b.goals?.name,
        category: b.goals?.category,
        day: dayLabel,
        time: scheduledDate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
        duration_mins: b.duration_mins,
        type: b.type,
        can_do_now: true,
      };
    });
    
    const tomorrowTasks = tasks.filter(t => t.day === 'Tomorrow');
    const bestSuggestion = tomorrowTasks.length > 0 ? tomorrowTasks[0] : tasks[0];
    
    return JSON.stringify({
      success: true,
      best_suggestion: bestSuggestion,
      all_upcoming: tasks,
      message: `You could get ahead by doing "${bestSuggestion.name}" (${bestSuggestion.duration_mins} mins) - it's scheduled for ${bestSuggestion.day} at ${bestSuggestion.time}. Want to knock it out now?`,
    });
  } catch (error: any) {
    return JSON.stringify({ success: false, error: error.message });
  }
}

async function executeCheckConflicts(
  userId: string,
  params: { date: string; start_time: string; end_time: string }
): Promise<string> {
  try {
    const { date, start_time, end_time } = params;
    
    const dayStart = new Date(`${date}T00:00:00`);
    const dayEnd = new Date(`${date}T23:59:59`);
    
    const { data: blocks, error } = await supabase
      .from('schedule_blocks')
      .select('*')
      .eq('user_id', userId)
      .gte('scheduled_start', dayStart.toISOString())
      .lte('scheduled_start', dayEnd.toISOString());
    
    if (error) throw error;
    
    const [startHours, startMins] = start_time.split(':').map(Number);
    const [endHours, endMins] = end_time.split(':').map(Number);
    const checkStart = startHours * 60 + startMins;
    const checkEnd = endHours * 60 + endMins;
    
    const conflicts: Array<{ id: string; name: string; type: string; time: string; duration: number }> = [];
    
    for (const block of blocks || []) {
      const blockDate = new Date(block.scheduled_start);
      const blockStart = blockDate.getHours() * 60 + blockDate.getMinutes();
      const blockEnd = blockStart + block.duration_mins;
      
      if (checkStart < blockEnd && checkEnd > blockStart) {
        const blockStartTime = `${Math.floor(blockStart/60).toString().padStart(2,'0')}:${(blockStart%60).toString().padStart(2,'0')}`;
        const blockEndTime = `${Math.floor(blockEnd/60).toString().padStart(2,'0')}:${(blockEnd%60).toString().padStart(2,'0')}`;
        
        conflicts.push({
          id: block.id,
          name: block.notes?.split('|||')[0] || block.type,
          type: block.type,
          time: `${blockStartTime}-${blockEndTime}`,
          duration: block.duration_mins,
        });
      }
    }
    
    if (conflicts.length === 0) {
      return JSON.stringify({ 
        success: true, 
        available: true,
        conflicts: [],
        message: `${start_time} to ${end_time} on ${date} is free!`
      });
    } else {
      return JSON.stringify({ 
        success: true, 
        available: false,
        conflicts: conflicts,
        message: `That time conflicts with: ${conflicts.map(c => `${c.name} (${c.time})`).join(', ')}`
      });
    }
  } catch (error: any) {
    return JSON.stringify({ success: false, error: error.message });
  }
}

async function executeFindBestRescheduleTime(
  userId: string,
  params: { session_id: string; target_date: string }
): Promise<string> {
  try {
    const { session_id, target_date } = params;
    
    const { data: session, error: sessionError } = await supabase
      .from('schedule_blocks')
      .select('*, goals(name)')
      .eq('id', session_id)
      .single();
    
    if (sessionError || !session) {
      return JSON.stringify({ success: false, error: 'Session not found' });
    }
    
    const sessionName = session.notes?.split('|||')[0] || session.goals?.name || 'Session';
    const sessionDuration = session.duration_mins;
    
    const dayStart = new Date(`${target_date}T00:00:00`);
    const dayEnd = new Date(`${target_date}T23:59:59`);
    
    const { data: existingBlocks, error: blocksError } = await supabase
      .from('schedule_blocks')
      .select('*')
      .eq('user_id', userId)
      .gte('scheduled_start', dayStart.toISOString())
      .lte('scheduled_start', dayEnd.toISOString())
      .neq('id', session_id)
      .order('scheduled_start', { ascending: true });
    
    if (blocksError) throw blocksError;
    
    const busyPeriods: { start: number; end: number; name: string }[] = [];
    for (const block of existingBlocks || []) {
      const blockDate = new Date(block.scheduled_start);
      const blockStart = blockDate.getHours() * 60 + blockDate.getMinutes();
      const blockEnd = blockStart + block.duration_mins;
      busyPeriods.push({ start: blockStart, end: blockEnd, name: block.notes?.split('|||')[0] || block.type });
    }
    
    busyPeriods.sort((a, b) => a.start - b.start);
    
    const dayStartMins = 7 * 60;
    const dayEndMins = 22 * 60;
    
    const availableSlots: { start: string; end: string; duration: number }[] = [];
    let currentTime = dayStartMins;
    
    for (const busy of busyPeriods) {
      if (busy.start > currentTime && busy.start - currentTime >= sessionDuration) {
        const slotEnd = Math.min(busy.start, currentTime + 180);
        availableSlots.push({
          start: `${Math.floor(currentTime/60).toString().padStart(2,'0')}:${(currentTime%60).toString().padStart(2,'0')}`,
          end: `${Math.floor(slotEnd/60).toString().padStart(2,'0')}:${(slotEnd%60).toString().padStart(2,'0')}`,
          duration: slotEnd - currentTime
        });
      }
      currentTime = Math.max(currentTime, busy.end);
    }
    
    if (dayEndMins > currentTime && dayEndMins - currentTime >= sessionDuration) {
      const slotEnd = Math.min(dayEndMins, currentTime + 180);
      availableSlots.push({
        start: `${Math.floor(currentTime/60).toString().padStart(2,'0')}:${(currentTime%60).toString().padStart(2,'0')}`,
        end: `${Math.floor(slotEnd/60).toString().padStart(2,'0')}:${(slotEnd%60).toString().padStart(2,'0')}`,
        duration: slotEnd - currentTime
      });
    }
    
    let bestSlot: { start: string; end: string } | null = null;
    const preferredTimes = [
      { start: 9 * 60, end: 12 * 60 },
      { start: 14 * 60, end: 17 * 60 },
      { start: 17 * 60, end: 20 * 60 },
      { start: 7 * 60, end: 9 * 60 },
    ];
    
    for (const pref of preferredTimes) {
      for (const slot of availableSlots) {
        const slotStartMins = parseInt(slot.start.split(':')[0]) * 60 + parseInt(slot.start.split(':')[1]);
        if (slotStartMins >= pref.start && slotStartMins < pref.end) {
          bestSlot = slot;
          break;
        }
      }
      if (bestSlot) break;
    }
    
    if (!bestSlot && availableSlots.length > 0) {
      bestSlot = availableSlots[0];
    }
    
    const scheduleDisplay = busyPeriods.map(b => 
      `${Math.floor(b.start/60).toString().padStart(2,'0')}:${(b.start%60).toString().padStart(2,'0')}-${Math.floor(b.end/60).toString().padStart(2,'0')}:${(b.end%60).toString().padStart(2,'0')}: ${b.name}`
    );
    
    const targetDateObj = new Date(target_date);
    const dayName = targetDateObj.toLocaleDateString('en-GB', { weekday: 'long' });
    const dateDisplay = targetDateObj.toLocaleDateString('en-GB', { day: 'numeric', month: 'long' });
    
    if (bestSlot) {
      const [startH, startM] = bestSlot.start.split(':').map(Number);
      const endMins = startH * 60 + startM + sessionDuration;
      const suggestedEndTime = `${Math.floor(endMins/60).toString().padStart(2,'0')}:${(endMins%60).toString().padStart(2,'0')}`;
      
      return JSON.stringify({
        success: true,
        session_id: session_id,
        session_name: sessionName,
        session_duration: sessionDuration,
        target_day: `${dayName}, ${dateDisplay}`,
        target_date: target_date,
        existing_schedule: scheduleDisplay.length > 0 ? scheduleDisplay : ['No existing commitments'],
        suggested_time: bestSlot.start,
        suggested_end_time: suggestedEndTime,
        all_available_slots: availableSlots.slice(0, 5),
        message: `Best time for "${sessionName}" (${sessionDuration} mins) on ${dayName} would be ${bestSlot.start}-${suggestedEndTime}. Want me to move it there, or would you prefer a different time?`
      });
    } else {
      return JSON.stringify({
        success: true,
        session_id: session_id,
        session_name: sessionName,
        session_duration: sessionDuration,
        target_day: `${dayName}, ${dateDisplay}`,
        target_date: target_date,
        existing_schedule: scheduleDisplay,
        suggested_time: null,
        all_available_slots: [],
        message: `${dayName} looks quite full! Here's what's scheduled: ${scheduleDisplay.join(', ')}. Would you like to try a different day?`
      });
    }
  } catch (error: any) {
    return JSON.stringify({ success: false, error: error.message });
  }
}

async function executeGetSchedule(
  userId: string,
  params: { date: string }
): Promise<string> {
  try {
    const { date } = params;
    
    let startDate: Date;
    let endDate: Date;
    const now = new Date();
    
    if (date === 'today') {
      startDate = new Date(now.toISOString().split('T')[0]);
      endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 1);
    } else if (date === 'tomorrow') {
      startDate = new Date(now);
      startDate.setDate(startDate.getDate() + 1);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 1);
    } else if (date === 'this_week') {
      startDate = new Date(now);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 7);
    } else {
      startDate = new Date(date);
      endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 1);
    }
    
    const { data: blocks, error } = await supabase
      .from('schedule_blocks')
      .select('*, goals(name, category)')
      .eq('user_id', userId)
      .gte('scheduled_start', startDate.toISOString())
      .lt('scheduled_start', endDate.toISOString())
      .order('scheduled_start', { ascending: true });
    
    if (error) throw error;
    
    const schedule = (blocks || []).map(b => {
      const time = new Date(b.scheduled_start);
      return {
        id: b.id,
        time: time.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
        name: b.notes?.split('|||')[0] || b.goals?.name || b.type,
        type: b.type,
        duration: b.duration_mins,
        status: b.status,
        goal: b.goals?.name,
      };
    });
    
    return JSON.stringify({ 
      success: true, 
      date: date,
      schedule: schedule,
      count: schedule.length
    });
  } catch (error: any) {
    return JSON.stringify({ success: false, error: error.message });
  }
}

// Propose action - just returns what would happen
async function executeProposeAction(
  userId: string,
  params: { action_type: string; description: string; details: any; conflicts?: any[] }
): Promise<string> {
  // This doesn't execute anything - it just formats the proposal
  return JSON.stringify({
    success: true,
    proposed: true,
    action_type: params.action_type,
    description: params.description,
    details: params.details,
    conflicts: params.conflicts || [],
    message: `Proposed: ${params.description}. Awaiting user confirmation.`,
  });
}

// Execute confirmed action - only called after user confirms
async function executeConfirmedAction(
  userId: string,
  params: { action_type: string; params: any }
): Promise<string> {
  const { action_type, params: actionParams } = params;
  
  try {
    switch (action_type) {
      case 'create_event': {
        const { date, start_time, end_time, title, type = 'event' } = actionParams;
        
        const [startHours, startMins] = start_time.split(':').map(Number);
        const [endHours, endMins] = end_time.split(':').map(Number);
        const durationMins = (endHours * 60 + endMins) - (startHours * 60 + startMins);
        
        if (durationMins <= 0) {
          return JSON.stringify({ success: false, error: 'End time must be after start time' });
        }
        
        const scheduledStart = new Date(`${date}T${start_time}:00`);
        
        const { data: newBlock, error } = await supabase
          .from('schedule_blocks')
          .insert({
            user_id: userId,
            goal_id: null,
            type: type,
            scheduled_start: scheduledStart.toISOString(),
            duration_mins: durationMins,
            notes: title,
            flexibility: 'fixed',
            created_by: 'user',
            status: 'scheduled',
          })
          .select()
          .single();
        
        if (error) throw error;
        
        return JSON.stringify({ 
          success: true, 
          message: `‚úÖ Created "${title}" on ${date} from ${start_time} to ${end_time}`,
          block: newBlock
        });
      }
      
      case 'delete_block': {
        const { block_id, reason } = actionParams;
        
        // First get the block to confirm it exists and get its name
        const { data: block, error: fetchError } = await supabase
          .from('schedule_blocks')
          .select('*')
          .eq('id', block_id)
          .single();
        
        if (fetchError || !block) {
          return JSON.stringify({ success: false, error: 'Block not found' });
        }
        
        const blockName = block.notes?.split('|||')[0] || block.type;
        
        const { error: deleteError } = await supabase
          .from('schedule_blocks')
          .delete()
          .eq('id', block_id);
        
        if (deleteError) throw deleteError;
        
        return JSON.stringify({ 
          success: true, 
          message: `‚úÖ Deleted "${blockName}"${reason ? ` (${reason})` : ''}`,
        });
      }
      
      case 'reschedule_session': {
        const { session_id, new_date, new_time } = actionParams;
        
        const { data: block, error: fetchError } = await supabase
          .from('schedule_blocks')
          .select('*, goals(name)')
          .eq('id', session_id)
          .single();
        
        if (fetchError || !block) {
          return JSON.stringify({ success: false, error: 'Session not found' });
        }
        
        const newScheduledStart = new Date(`${new_date}T${new_time}:00`);
        
        const { error: updateError } = await supabase
          .from('schedule_blocks')
          .update({
            scheduled_start: newScheduledStart.toISOString(),
            original_scheduled_start: block.original_scheduled_start || block.scheduled_start,
          })
          .eq('id', session_id);
        
        if (updateError) throw updateError;
        
        const sessionName = block.notes?.split('|||')[0] || block.goals?.name || 'Session';
        const [newHours, newMins] = new_time.split(':').map(Number);
        const endMins = newHours * 60 + newMins + block.duration_mins;
        const endTime = `${Math.floor(endMins/60).toString().padStart(2,'0')}:${(endMins%60).toString().padStart(2,'0')}`;
        const dayName = newScheduledStart.toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'short' });
        
        return JSON.stringify({ 
          success: true, 
          message: `‚úÖ Moved "${sessionName}" to ${dayName} at ${new_time}-${endTime}`,
        });
      }
      
      case 'complete_session': {
        const { session_id, notes } = actionParams;
        
        const { data: block, error: fetchError } = await supabase
          .from('schedule_blocks')
          .select('*, goals(name)')
          .eq('id', session_id)
          .single();
        
        if (fetchError || !block) {
          return JSON.stringify({ success: false, error: 'Session not found' });
        }
        
        const { error: updateError } = await supabase
          .from('schedule_blocks')
          .update({
            status: 'completed',
            completed_at: new Date().toISOString(),
            notes: notes || block.notes,
          })
          .eq('id', session_id);
        
        if (updateError) throw updateError;
        
        const sessionName = block.notes?.split('|||')[0] || block.goals?.name || 'Session';
        
        return JSON.stringify({ 
          success: true, 
          message: `‚úÖ Completed "${sessionName}"! Great work! üéâ`
        });
      }
      
      case 'skip_session': {
        const { session_id, reason } = actionParams;
        
        const { data: block, error: fetchError } = await supabase
          .from('schedule_blocks')
          .select('*, goals(name, target_date, plan)')
          .eq('id', session_id)
          .single();
        
        if (fetchError || !block) {
          return JSON.stringify({ success: false, error: 'Session not found' });
        }
        
        const { error: updateError } = await supabase
          .from('schedule_blocks')
          .update({ status: 'skipped' })
          .eq('id', session_id);
        
        if (updateError) throw updateError;
        
        let deadlineImpact = null;
        if (block.goal_id && block.goals?.target_date) {
          const sessionsPerWeek = block.goals.plan?.sessions_per_week || 3;
          const daysImpact = Math.ceil(7 / sessionsPerWeek);
          
          const currentTarget = new Date(block.goals.target_date);
          currentTarget.setDate(currentTarget.getDate() + daysImpact);
          
          await supabase
            .from('goals')
            .update({ target_date: currentTarget.toISOString().split('T')[0] })
            .eq('id', block.goal_id);
          
          deadlineImpact = `Goal deadline pushed to ${currentTarget.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}`;
        }
        
        const sessionName = block.notes?.split('|||')[0] || block.goals?.name || 'Session';
        
        return JSON.stringify({ 
          success: true, 
          message: `‚úÖ Skipped "${sessionName}".${deadlineImpact ? ` ${deadlineImpact}` : ''}`,
          deadline_impact: deadlineImpact
        });
      }
      
      default:
        return JSON.stringify({ success: false, error: `Unknown action type: ${action_type}` });
    }
  } catch (error: any) {
    return JSON.stringify({ success: false, error: error.message });
  }
}

// Execute a tool call
async function executeTool(userId: string, toolName: string, toolInput: any): Promise<string> {
  switch (toolName) {
    case 'propose_action':
      return executeProposeAction(userId, toolInput);
    case 'execute_confirmed_action':
      return executeConfirmedAction(userId, toolInput);
    case 'get_upcoming_tasks':
      return executeGetUpcomingTasks(userId, toolInput);
    case 'find_best_reschedule_time':
      return executeFindBestRescheduleTime(userId, toolInput);
    case 'get_schedule':
      return executeGetSchedule(userId, toolInput);
    case 'check_conflicts':
      return executeCheckConflicts(userId, toolInput);
    default:
      return JSON.stringify({ success: false, error: 'Unknown tool' });
  }
}

/**
 * POST /api/ai-chat
 * AI-powered chat endpoint using OpenAI
 */
router.post('/', async (req: Request, res: Response) => {
  try {
    const { user_id, message, conversation_history = [], today_tasks = [] } = req.body;

    if (!user_id || !message) {
      return res.status(400).json({ error: 'Missing user_id or message' });
    }

    console.log(`\nü§ñ AI Chat: "${message.substring(0, 50)}..."`);

    const now = new Date();
    const todayStr = now.toISOString().split('T')[0];
    const currentTime = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
    const dayName = now.toLocaleDateString('en-GB', { weekday: 'long' });

    const pendingTasks = today_tasks.filter((t: any) => t.status !== 'completed');
    const completedTasks = today_tasks.filter((t: any) => t.status === 'completed');
    
    let tasksContext = '';
    if (today_tasks.length > 0) {
      tasksContext = `\n\nTODAY'S SCHEDULE:\n`;
      for (const task of today_tasks) {
        const time = new Date(task.scheduled_time).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
        const status = task.status === 'completed' ? '‚úì DONE' : 'pending';
        tasksContext += `- [${status}] ${task.name} at ${time} (${task.duration_mins}min) - ID: ${task.id}\n`;
        if (task.goal_name) tasksContext += `  Goal: ${task.goal_name}\n`;
      }
      tasksContext += `\nSummary: ${pendingTasks.length} pending, ${completedTasks.length} completed`;
    }

    const systemPrompt = `You are Pepzi, a friendly and helpful AI personal assistant for productivity and goal tracking.

CURRENT CONTEXT:
- Date: ${dayName}, ${todayStr}
- Time: ${currentTime}
- User ID: ${user_id}
${tasksContext}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è  CRITICAL RULE: ALWAYS ASK FOR CONFIRMATION BEFORE EXECUTING ANY ACTION ‚ö†Ô∏è
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

You must NEVER execute actions without explicit user confirmation. Follow this pattern:

1. USER REQUESTS SOMETHING ‚Üí You PROPOSE the action and ASK for confirmation
2. USER CONFIRMS (says "yes", "do it", "go ahead", "confirm", "ok", etc.) ‚Üí THEN you execute

WORKFLOW FOR ALL ACTIONS:

Step 1: When user wants to do something, use check_conflicts or get_schedule to understand the situation
Step 2: Use propose_action to describe what you WILL do and ask "Should I go ahead?"
Step 3: WAIT for user to confirm
Step 4: ONLY after confirmation, use execute_confirmed_action

EXAMPLE - Creating an event:
User: "Book Christmas day off from 12 to 3pm"
You: [check_conflicts for that time]
You: [If conflicts found] "I can book December 25th from 12:00-15:00 as time off. 
     However, this conflicts with your commute block from 13:00-18:00. 
     Would you like me to:
     1. Delete the commute and book your time off
     2. Adjust the time to avoid the conflict
     Which would you prefer?"
User: "Delete the commute and book it"
You: [execute_confirmed_action to delete commute]
You: [execute_confirmed_action to create event]
You: "Done! I've removed the commute and booked your time off from 12:00-15:00 ‚úì"

EXAMPLE - Rescheduling:
User: "Move my gym session to tomorrow"
You: [find_best_reschedule_time]
You: "I can move your gym session to tomorrow at 10:00-11:00. Should I go ahead?"
User: "Yes"
You: [execute_confirmed_action]
You: "Done! Moved to tomorrow at 10:00 ‚úì"

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üö´  THINGS YOU MUST NEVER DO:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

- NEVER skip sessions unless user explicitly asks to skip that specific session
- NEVER complete sessions unless user explicitly asks to complete that specific session
- NEVER delete blocks unless user explicitly asks or confirms deletion
- NEVER assume what the user wants - always ask if unclear
- NEVER execute multiple unrelated actions - focus on what user asked

YOUR CAPABILITIES:
1. CREATE EVENTS: Book time blocks (propose first, execute after confirmation)
2. DELETE BLOCKS: Remove existing blocks (always ask first)
3. RESCHEDULE: Move sessions (find time, propose, execute after confirmation)
4. COMPLETE: Mark done (only when user specifically asks)
5. SKIP: Skip sessions (only when user specifically asks)
6. CHECK SCHEDULE: Look up plans
7. GET UPCOMING TASKS: Find tasks user could do early

DATE PARSING (today is ${todayStr}):
- "Christmas" or "Christmas day" = 2024-12-25
- "Saturday" = find next Saturday
- "tomorrow" = add 1 day
- Always convert to YYYY-MM-DD format

PERSONALITY:
- Be conversational and friendly
- Use emojis sparingly
- Be proactive about asking clarifying questions
- Keep responses concise
- Always confirm before acting`;

    const messages: any[] = [
      { role: 'system', content: systemPrompt },
      ...conversation_history.slice(-10).map((msg: any) => ({
        role: msg.type === 'user' ? 'user' : 'assistant',
        content: msg.content,
      })),
      { role: 'user', content: message },
    ];

    let response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: messages,
      tools: tools,
      tool_choice: 'auto',
      temperature: 0.7,
      max_tokens: 1024,
    });

    let finalResponse = '';
    let actions: any[] = [];
    let iterations = 0;
    const maxIterations = 5;

    while (response.choices[0]?.message?.tool_calls && iterations < maxIterations) {
      iterations++;
      
      const toolCalls = response.choices[0].message.tool_calls;
      messages.push(response.choices[0].message);
      
      for (const toolCall of toolCalls) {
        const toolName = toolCall.function.name;
        const toolInput = JSON.parse(toolCall.function.arguments);
        
        console.log(`üîß Tool: ${toolName}`, toolInput);
        
        const result = await executeTool(user_id, toolName, toolInput);
        const parsedResult = JSON.parse(result);
        
        actions.push({
          tool: toolName,
          input: toolInput,
          result: parsedResult,
        });
        
        messages.push({
          role: 'tool',
          tool_call_id: toolCall.id,
          content: result,
        });
      }
      
      response = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: messages,
        tools: tools,
        tool_choice: 'auto',
        temperature: 0.7,
        max_tokens: 1024,
      });
    }

    finalResponse = response.choices[0]?.message?.content || "I've completed that for you!";

    console.log(`‚úÖ AI Response: "${finalResponse.substring(0, 100)}..."`);

    return res.json({
      success: true,
      response: finalResponse,
      actions: actions,
    });

  } catch (error: any) {
    console.error('‚ùå AI Chat error:', error);
    return res.status(500).json({
      error: 'AI chat failed',
      message: error.message,
      response: "Sorry, I'm having trouble right now. Please try again!",
    });
  }
});

export default router;
=== BACKEND SERVICES ===

--- openai.ts ---
import OpenAI from 'openai';

// Initialize OpenAI client
const apiKey = process.env.OPENAI_API_KEY;

if (!apiKey) {
  throw new Error('Missing OPENAI_API_KEY in .env file');
}

export const openai = new OpenAI({ apiKey });

/**
 * Extract structured intents from user message
 * This is the core of Pepzi's natural language understanding
 * NOW WITH MEMORY INTEGRATION! üß†
 */
export async function extractIntents(
  userMessage: string,
  context: any
): Promise<any> {
  try {
    // Build system prompt with memory context
    let systemPrompt = `You are Pepzi, an AI life operating system assistant.

Your job is to understand natural language requests and extract structured intents.

Available intent types:
- log_activity: User is logging something they did
- reschedule_block: User wants to move a scheduled activity
- create_block: User wants to add a new activity
- query_progress: User is asking about their progress
- general_chat: General conversation

Current context:
- Today: ${new Date().toISOString().split('T')[0]}
- User goals: ${JSON.stringify(context.goals || [])}
- Today's schedule: ${JSON.stringify(context.todaySchedule || [])}`;

    // üß† ADD MEMORY CONTEXT IF AVAILABLE
    if (context.memories && context.memories.trim().length > 0) {
      systemPrompt += `

IMPORTANT - KNOWN PATTERNS ABOUT THIS USER:
${context.memories}

You MUST use these patterns when giving advice. For example, if the user asks when to schedule something and you know they prefer mornings, recommend mornings and mention why (based on their past behavior).`;
    }

    systemPrompt += `

Extract intents from the user's message and respond with JSON only.

Format:
{
  "intents": [
    {
      "type": "intent_type",
      "data": { ... relevant data ... }
    }
  ],
  "response": "Natural language response to user"
}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: userMessage
        }
      ],
      temperature: 0.7,
      max_tokens: 1000
    });

    const content = response.choices[0]?.message?.content || '{}';
    
    // Try to parse JSON, stripping markdown if present
    let cleanContent = content.trim();
    if (cleanContent.startsWith('```json')) {
      cleanContent = cleanContent.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    }
    
    return JSON.parse(cleanContent);
  } catch (error) {
    console.error('OpenAI API error:', error);
    throw error;
  }
}

/**
 * Generate text embeddings for semantic memory
 */
export async function createEmbedding(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: text
    });
    
    return response.data[0].embedding;
  } catch (error) {
    console.error('Embedding creation error:', error);
    throw error;
  }
}

/**
 * Simple chat completion (for general responses)
 */
export async function simpleCompletion(
  message: string,
  systemPrompt?: string
): Promise<string> {
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        ...(systemPrompt ? [{ role: 'system' as const, content: systemPrompt }] : []),
        { role: 'user' as const, content: message }
      ],
      temperature: 0.7,
      max_tokens: 500
    });
    
    return response.choices[0]?.message?.content || 'No response generated.';
  } catch (error) {
    console.error('Simple completion error:', error);
    throw error;
  }
}

/**
 * JSON-only completion: forces the model to return valid JSON
 */
export async function jsonCompletion<T = any>(
  prompt: string,
  systemPrompt?: string
): Promise<T> {
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        {
          role: 'system',
          content:
            systemPrompt ??
            'You are a helper that MUST respond with a single valid JSON object and nothing else.',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      temperature: 0.4,
      max_tokens: 1000,
    });

    const content = response.choices[0]?.message?.content || '{}';

    return JSON.parse(content) as T;
  } catch (error) {
    console.error('jsonCompletion error:', error);
    throw error;
  }
}

/**
 * Generate a realistic weekly training plan from goal + milestones
 * üî• NEW: Turns milestones into actual week-by-week training schedule
 */
export async function generateWeeklyTrainingPlan(params: {
  goalName: string;
  category: string;
  description?: string;
  currentLevel: string;
  timeline: string;
  weeklyHours: number;
  totalHours: number;
  milestones: Array<{ name: string; hours: number }>;
}): Promise<any> {
  const {
    goalName,
    category,
    description,
    currentLevel,
    timeline,
    weeklyHours,
    totalHours,
    milestones,
  } = params;

  const systemPrompt = `You are a training plan architect. You build realistic, progressive weekly plans.

CRITICAL: Output ONLY valid JSON in this exact format:

{
  "plan": {
    "summary": "High-level plan summary",
    "realism_notes": "Any safety/adjustment notes",
    "weekly_hours": 6,
    "estimated_total_hours": 150,
    "weeks": [
      {
        "week_number": 1,
        "focus": "Main focus this week",
        "sessions_per_week": 3,
        "sessions": [
          {
            "name": "Short session name",
            "description": "What to do in detail",
            "notes": "Optional tips"
          }
        ]
      }
    ],
    "milestones": [
      {
        "name": "Milestone name",
        "target_week": 4,
        "criteria": "How to verify completion"
      }
    ]
  }
}`;

  const userPrompt = `Goal: "${goalName}"
Category: ${category}
Description: ${description || 'N/A'}
Current level: ${currentLevel}
Timeline: ${timeline}
Weekly hours: ${weeklyHours}
Total hours: ${totalHours}

Milestones:
${milestones.map((m, i) => `${i + 1}. ${m.name} (${m.hours}h)`).join('\n')}

Create a progressive weekly plan with SPECIFIC session details.

Examples of GOOD session descriptions:
- Running: "3x800m at 5K pace, 2min rest between reps"
- Climbing: "Boulder V4-V5 problems, focus on footwork and balance"
- Business: "Customer interviews: reach out to 10 potential users, conduct 3 calls"
- Language: "30min conversation practice with native speaker on specific topics"

Examples of BAD (too vague):
- "Training session"
- "Work on project"
- "Practice skills"

Be SPECIFIC and actionable!`;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      temperature: 0.5,
      max_tokens: 3000,
    });

    const content = response.choices[0]?.message?.content || '{}';
    return JSON.parse(content);
  } catch (error) {
    console.error('‚ùå Weekly plan generation error:', error);
    throw error;
  }
}
--- planner.ts ---
import { supabase } from './supabase';
import { addDays, startOfDay, setHours } from 'date-fns';

/**
 * Generate weekly schedule for a user
 */
export async function generateWeeklySchedule(userId: string) {
  try {
    console.log(`üìÖ Generating weekly schedule for user ${userId}`);

    const { data: goals, error } = await supabase
      .from('goals')
      .select('*')
      .eq('user_id', userId)
      .eq('status', 'active');

    if (error) throw error;
    if (!goals || goals.length === 0) {
      return { message: 'No active goals found' };
    }

    const totalHoursNeeded = goals.reduce((sum, goal) => {
      return sum + (goal.plan?.weekly_hours || 0);
    }, 0);

    console.log(`‚è∞ Total weekly hours needed: ${totalHoursNeeded}`);

    const blocks: any[] = [];
    const today = startOfDay(new Date());

    for (const goal of goals) {
      const weeklyHours = goal.plan?.weekly_hours || 0;
      if (weeklyHours === 0) continue;

      const sessionsPerWeek = Math.ceil(weeklyHours / 1.5);
      const hoursPerSession = weeklyHours / sessionsPerWeek;

      for (let i = 0; i < sessionsPerWeek && i < 7; i++) {
        const day = addDays(today, i);
        const startTime = setHours(day, 9 + (i * 2) % 12);

        blocks.push({
          user_id: userId,
          goal_id: goal.id,
          type: getBlockType(goal.category),
          scheduled_start: startTime.toISOString(),
          duration_mins: Math.round(hoursPerSession * 60),
          flexibility: 'movable',
          created_by: 'ai',
          status: 'scheduled'
        });
      }
    }

    const { data: savedBlocks, error: saveError } = await supabase
      .from('schedule_blocks')
      .insert(blocks)
      .select();

    if (saveError) throw saveError;

    console.log(`‚úÖ Created ${savedBlocks?.length || 0} schedule blocks`);

    return {
      blocks: savedBlocks,
      total_hours: totalHoursNeeded,
      message: `Generated ${savedBlocks?.length} schedule blocks for the week`
    };

  } catch (error) {
    console.error('Error generating schedule:', error);
    throw error;
  }
}

/**
 * Get block type based on goal category
 */
function getBlockType(category: string): string {
  const typeMap: { [key: string]: string } = {
    'fitness': 'workout',
    'money': 'deep_work',
    'skill': 'practice',
    'social': 'social',
    'travel': 'planning',
    'habit': 'routine',
    'experience': 'event'
  };
  return typeMap[category] || 'activity';
}

/**
 * Reschedule a block
 */
export async function rescheduleBlock(
  blockId: string,
  newStartTime: Date
) {
  try {
    const { data: block, error } = await supabase
      .from('schedule_blocks')
      .update({
        scheduled_start: newStartTime.toISOString(),
        status: 'rescheduled'
      })
      .eq('id', blockId)
      .select()
      .single();

    if (error) throw error;

    console.log(`üîÑ Rescheduled block to ${newStartTime.toISOString()}`);

    return block;
  } catch (error) {
    console.error('Error rescheduling block:', error);
    throw error;
  }
}

=== FRONTEND ===

--- api.ts ---
import axios from 'axios';

// Hardcoded production backend URL - bypasses Next.js rewrites
const API_BASE_URL = 'https://pepzi-backend-1029121217006.europe-west1.run.app';

export const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 120000,
});

// Types
export interface ChatMessage {
  user_id: string;
  message: string;
  conversation_state?: any;
}

export interface ChatResponse {
  response: string;
  intents: any[];
  actions_taken: any[];
  ui_updates: {
    schedule_refresh: boolean;
    goals_refresh: boolean;
  };
}

export interface SmartChatResponse {
  response: string;
  show_confirmation: boolean;
  confirmation_data?: {
    block_id: string;
    session_name: string;
    goal_name: string;
    tracked_data: Record<string, any>;
  };
  state: any;
  ui_updates: any;
}

export interface TodayTask {
  id: string;
  name: string;
  description: string;
  tip: string;
  goal_name: string;
  goal_id: string;
  category: string;
  scheduled_time: string;
  duration_mins: number;
  status: string;
  completed_at?: string;
  tracked_data?: Record<string, any>;
  notes?: string;
  previous_notes?: string;
  tracking_requirements: Array<{
    key: string;
    label: string;
    type: string;
    unit?: string;
  }>;
}

export interface TodaySummary {
  date: string;
  tasks: TodayTask[];
  summary: {
    total: number;
    pending: number;
    completed: number;
  };
}

export interface GoalProgress {
  totalSessions: number;
  totalHours: number;
  targetHours: number;
  percentComplete: number;
  thisWeekCompleted: number;
  weeklyTarget: number;
  onTrack: boolean;
  status: 'on_track' | 'slightly_behind' | 'behind';
}

export interface Goal {
  id: string;
  user_id: string;
  name: string;
  category: string;
  target_date?: string;
  description?: string;
  status?: string;
  plan?: any;
  progress?: any;
  created_at?: string;
  micro_goals?: any[];
  preferred_days?: string[];
  preferred_time?: 'morning' | 'afternoon' | 'evening' | 'any';
  intensity?: string;
}

export interface ScheduleBlock {
  id: string;
  user_id: string;
  type: string;
  scheduled_start: string;
  duration_mins: number;
  status: string;
  notes?: string;
  goal_id?: string;
  created_by?: string;
  completed_at?: string;
  original_scheduled_start?: string;
  goals?: { name: string; category?: string };
}

export interface UserAvailability {
  id?: string;
  user_id: string;
  wake_time: string;
  sleep_time: string;
  work_schedule: Record<string, { start: string; end: string } | null>;
  daily_commute_mins: number;
  fixed_commitments: Array<{ day: string; start: string; end: string; name: string }>;
  preferred_workout_time: string;
  total_free_hours_per_week?: number;
  total_busy_hours_per_week?: number;
}

export interface Milestone {
  name: string;
  hours: number;
  week?: number;
  target_week?: number;
}

export interface PlanEdits {
  editInstructions: string;
}

export interface CreatePlanPayload {
  milestones: Milestone[];
  weekly_hours: number;
  sessions_per_week: number;
  total_hours: number;
  tracking_criteria: string[];
  plan_edits?: PlanEdits;
}

export interface ConversationResponse {
  complete: boolean;
  message: string;
  goal?: any;
  milestones?: Milestone[];
  tracking_criteria?: string[];
  weekly_hours?: number;
  sessions_per_week?: number;
  total_hours?: number;
  state?: any;
  plan_edits?: PlanEdits;
  preview?: any;
}

export interface ScheduleGenerateResponse {
  success: boolean;
  schedule: ScheduleBlock[];
  message: string;
  warning?: string | null;
  stats: {
    sessions: number;
    totalHours: number;
    goalsScheduled: number;
  };
}

export interface RecurringBlockResponse {
  success: boolean;
  blocksCreated: number;
  type: string;
  days: string[];
  time: string;
  duration_mins: number;
  schedule_until: string;
  message: string;
}

// ============================================================
// CHAT API
// ============================================================

export const chatAPI = {
  sendMessage: async (data: ChatMessage): Promise<ChatResponse> => {
    const response = await api.post('/api/chat', data);
    return response.data;
  },
  smartMessage: async (data: { user_id: string; message: string; conversation_state?: any }): Promise<SmartChatResponse> => {
    const response = await api.post('/api/chat/message', data);
    return response.data;
  },
  confirmLog: async (data: { user_id: string; block_id: string; tracked_data: Record<string, any> }): Promise<{ success: boolean; block: ScheduleBlock; progress: GoalProgress | null; message: string; remaining_today: number }> => {
    const response = await api.post('/api/chat/confirm-log', data);
    return response.data;
  },
  getTodaySummary: async (userId: string): Promise<TodaySummary> => {
    const response = await api.get('/api/chat/today-summary', { params: { user_id: userId } });
    return response.data;
  },
  getGoalProgress: async (goalId: string): Promise<GoalProgress> => {
    const response = await api.get(`/api/chat/goal-progress/${goalId}`);
    return response.data;
  },
  getMissedSessions: async (userId: string): Promise<{ sessions: TodayTask[] }> => {
    const response = await api.get('/api/chat/missed-sessions', { params: { user_id: userId } });
    return response.data;
  },
};

// ============================================================
// GOALS API
// ============================================================

export const goalsAPI = {
  getGoals: async (userId: string): Promise<Goal[]> => {
    const response = await api.get('/api/goals', { params: { user_id: userId } });
    return response.data.goals;
  },
  createGoal: async (goal: Partial<Goal> & { user_id: string }): Promise<Goal> => {
    const response = await api.post('/api/goals', goal);
    return response.data.goal;
  },
  extractFromDreams: async (userId: string, text: string): Promise<Goal[]> => {
    const response = await api.post('/api/goals/from-dreams', { user_id: userId, text });
    return response.data.goals;
  },
  generatePlan: async (goalId: string, context?: string): Promise<any> => {
    const response = await api.post(`/api/goals/${goalId}/plan`, { context });
    return response.data;
  },
  generateTrainingPlan: async (goalId: string, context?: string): Promise<any> => {
    const response = await api.post(`/api/goals/${goalId}/generate-plan`, { context });
    return response.data;
  },
  conversation: async (userId: string, message: string, conversationState?: any): Promise<ConversationResponse> => {
    const response = await api.post('/api/goals/conversation', { user_id: userId, message, conversation_state: conversationState });
    return response.data;
  },
  createPlanWithMilestones: async (goalId: string, payload: CreatePlanPayload): Promise<any> => {
    const response = await api.post(`/api/goals/${goalId}/create-plan-with-milestones`, payload, { timeout: 300000 });
    return response.data;
  },
  deleteGoal: async (goalId: string): Promise<void> => {
    await api.delete(`/api/goals/${goalId}`);
  },
  deletePlan: async (goalId: string): Promise<void> => {
    await api.delete(`/api/goals/${goalId}/plan`);
  },
  getGoalSessions: async (goalId: string, limit?: number): Promise<{ sessions: Array<{ id: string; name: string; scheduled_start: string; completed_at: string; duration_mins: number; tracked_data: Record<string, any> }>; aggregates: { total_sessions: number; total_hours: number; total_minutes: number; avg_effort: number | null; total_distance_km: number | null } }> => {
    const response = await api.get(`/api/goals/${goalId}/sessions`, { params: { limit } });
    return response.data;
  },
  getAllProgress: async (userId: string): Promise<{ progress: Record<string, { total_sessions: number; total_minutes: number; total_hours: number }> }> => {
    const response = await api.get('/api/goals/all-progress', { params: { user_id: userId } });
    return response.data;
  },
  updateIntensity: async (goalId: string, intensity: string): Promise<any> => {
    const response = await api.patch(`/api/goals/${goalId}/intensity`, { intensity });
    return response.data;
  },
  updatePreferences: async (goalId: string, data: { preferred_days?: string[]; weekly_hours?: number; sessions_per_week?: number }): Promise<any> => {
    const response = await api.patch(`/api/goals/${goalId}/preferences`, data);
    return response.data;
  },
  getIntensifyPreview: async (goalId: string): Promise<{
    success: boolean;
    preview: Array<{
      id: string;
      before: { name: string; description: string; tip: string; duration_mins: number };
      after: { name: string; description: string; tip: string; duration_mins: number };
    }>;
    total_sessions: number;
    message: string;
  }> => {
    const response = await api.post(`/api/goals/${goalId}/intensify-preview`);
    return response.data;
  },
  applyIntensify: async (goalId: string, preview: any[]): Promise<{
    success: boolean;
    sessions_updated: number;
    message: string;
  }> => {
    const response = await api.post(`/api/goals/${goalId}/intensify-apply`, { preview });
    return response.data;
  },
  getTimeBudget: async (userId: string): Promise<{
    work_hours: number;
    commute_hours: number;
    event_hours: number;
    training_hours: number;
    committed_hours: number;
    awake_hours: number;
    free_hours: number;
  }> => {
    const response = await api.get('/api/goals/time-budget', { params: { user_id: userId } });
    return response.data;
  },
  getGoalSchedule: async (goalId: string): Promise<{
    sessions: any[];
    sessions_by_week: Record<number, any[]>;
    total_sessions: number;
  }> => {
    const response = await api.get(`/api/goals/${goalId}/schedule`);
    return response.data;
  },
};

// ============================================================
// SCHEDULE API
// ============================================================

export const scheduleAPI = {
  getSchedule: async (userId: string, startDate?: string, endDate?: string): Promise<ScheduleBlock[]> => {
    const response = await api.get('/api/schedule', { params: { user_id: userId, start_date: startDate, end_date: endDate } });
    return response.data.blocks;
  },
  getToday: async (userId: string): Promise<ScheduleBlock[]> => {
    const response = await api.get('/api/schedule/today', { params: { user_id: userId } });
    return response.data.blocks;
  },
  getBlocks: async (userId: string, startDate: string, endDate: string): Promise<{ blocks: ScheduleBlock[] }> => {
    const response = await api.get('/api/schedule', { params: { user_id: userId, start_date: startDate, end_date: endDate } });
    return response.data;
  },
  getWeek: async (userId: string, weekOffset: number = 0): Promise<ScheduleBlock[]> => {
    const today = new Date();
    const startOfWeek = new Date(today);
    startOfWeek.setDate(today.getDate() - today.getDay() + weekOffset * 7);
    startOfWeek.setHours(0, 0, 0, 0);
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 7);
    const response = await api.get('/api/schedule', { params: { user_id: userId, start_date: startOfWeek.toISOString().split('T')[0], end_date: endOfWeek.toISOString().split('T')[0] } });
    return response.data.blocks;
  },
  createBlock: async (block: { user_id: string; goal_id?: string; type: string; scheduled_start: string; duration_mins: number; notes?: string }): Promise<ScheduleBlock> => {
    const response = await api.post('/api/schedule', block);
    return response.data.block;
  },
  createRecurringBlock: async (data: {
    user_id: string;
    type: string;
    days: string[];
    start_time: string;
    end_time: string;
    notes?: string;
  }): Promise<RecurringBlockResponse> => {
    const response = await api.post('/api/schedule/recurring', data);
    return response.data;
  },
  updateBlock: async (blockId: string, updates: { scheduled_start?: string; duration_mins?: number; notes?: string }): Promise<ScheduleBlock> => {
    const response = await api.patch(`/api/schedule/${blockId}`, updates);
    return response.data.block;
  },
  updateBlockWithFuture: async (blockId: string, scheduledStart: string, applyToFuture: boolean): Promise<{ block: ScheduleBlock; updatedCount: number }> => {
    const response = await api.patch(`/api/schedule/${blockId}/with-future`, { scheduled_start: scheduledStart, apply_to_future: applyToFuture });
    return response.data;
  },
  completeBlock: async (blockId: string): Promise<ScheduleBlock> => {
    const response = await api.patch(`/api/schedule/${blockId}/complete`);
    return response.data.block;
  },
  deleteBlock: async (blockId: string): Promise<void> => {
    await api.delete(`/api/schedule/${blockId}`);
  },
  autoGenerate: async (userId: string): Promise<ScheduleGenerateResponse> => {
    const response = await api.post('/api/schedule/auto-generate', { user_id: userId });
    return response.data;
  },
  generateForGoal: async (userId: string, goalId: string, preferredDays?: string[], preferredTime?: string): Promise<{ success: boolean; blocksCreated: number; warning: string | null; message: string }> => {
    const response = await api.post('/api/schedule/generate-for-goal', { user_id: userId, goal_id: goalId, preferred_days: preferredDays, preferred_time: preferredTime }, { timeout: 180000 });
    return response.data;
  },
  reschedule: async (blockId: string, newStartTime: string): Promise<ScheduleBlock> => {
    const response = await api.patch(`/api/schedule/${blockId}/reschedule`, { new_start_time: newStartTime });
    return response.data.block;
  },
  completeBlockWithNotes: async (blockId: string, notes: string): Promise<{ success: boolean; block: ScheduleBlock; message: string }> => {
    const response = await api.patch(`/api/schedule/${blockId}/complete-with-notes`, { notes });
    return response.data;
  },
  skipBlock: async (blockId: string): Promise<{ success: boolean; deadline_impact: string | null; message: string }> => {
    const response = await api.patch(`/api/schedule/${blockId}/skip`);
    return response.data;
  },
  rescheduleBlock: async (blockId: string, option: 'later_today' | 'tomorrow' | 'custom', customTime?: string): Promise<{ success: boolean; block: ScheduleBlock; new_time: string; message: string }> => {
    const response = await api.patch(`/api/schedule/${blockId}/reschedule-smart`, { option, custom_time: customTime });
    return response.data;
  },
  pushToNextWeek: async (blockId: string): Promise<{ success: boolean; new_date: string; deadline_impact: string | null; message: string }> => {
    const response = await api.patch(`/api/schedule/${blockId}/push-to-next-week`);
    return response.data;
  },
  completeEarly: async (blockId: string, notes: string): Promise<{ success: boolean; block: ScheduleBlock; deadline_impact: string | null; message: string }> => {
    const response = await api.patch(`/api/schedule/${blockId}/complete-early`, { notes });
    return response.data;
  },
};

// ============================================================
// AVAILABILITY API
// ============================================================

export const availabilityAPI = {
  extract: async (userId: string, text: string): Promise<any> => {
    const response = await api.post('/api/availability/extract', { user_id: userId, text });
    return response.data;
  },
  save: async (userId: string, availability: any): Promise<any> => {
    const response = await api.post('/api/availability', { user_id: userId, ...availability });
    return response.data;
  },
  get: async (userId: string): Promise<{ availability: UserAvailability | null; has_availability: boolean }> => {
    const response = await api.get('/api/availability', { params: { user_id: userId } });
    return response.data;
  },
  checkFeasibility: async (userId: string): Promise<any> => {
    const response = await api.get('/api/availability/feasibility', { params: { user_id: userId } });
    return response.data;
  },
  update: async (userId: string, availability: any): Promise<any> => {
    const response = await api.post('/api/availability', { user_id: userId, ...availability });
    return response.data;
  },
};

export const goalsApi = goalsAPI;
--- store.ts ---
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UserStore {
  userId: string;
  setUserId: (id: string) => void;
}

export const useUserStore = create<UserStore>()(
  persist(
    (set) => ({
      userId: '550e8400-e29b-41d4-a957-146664440000', // Default test user
      setUserId: (id) => set({ userId: id }),
    }),
    {
      name: 'pepzi-user-storage',
    }
  )
);

--- today/page.tsx ---
'use client';

import { useState } from 'react';
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { useAuth } from '@/lib/auth-context';
import { Calendar as CalendarIcon, CheckCircle, Circle, Loader2, MessageSquare, ListTodo } from 'lucide-react';
import TodayTaskCard from '@/components/today/TodayTaskCard';
import TodayChat from '@/components/today/TodayChat';
import { chatAPI, scheduleAPI } from '@/lib/api';

interface TodayTask {
  id: string;
  name: string;
  description?: string;
  tip?: string;
  goal_name: string;
  goal_id?: string;
  category?: string;
  scheduled_time: string;
  duration_mins: number;
  status: string;
  completed_at?: string;
  notes?: string;
  previous_notes?: string;
  tracking_requirements?: Array<{
    key: string;
    label: string;
    type: string;
    unit?: string;
  }>;
}

export default function TodayPage() {
  const { user } = useAuth();
  const userId = user?.id || '';
  const queryClient = useQueryClient();
  const [showNotesModal, setShowNotesModal] = useState(false);
  const [activeTask, setActiveTask] = useState<TodayTask | null>(null);
  const [notes, setNotes] = useState('');
  
  // Mobile tab state
  const [mobileTab, setMobileTab] = useState<'tasks' | 'chat'>('tasks');

  // Fetch today's tasks
  const { data: todayData, isLoading } = useQuery({
    queryKey: ['today-summary', userId],
    queryFn: async () => {
      const data = await chatAPI.getTodaySummary(userId);
      return data;
    },
    refetchInterval: 30000,
  });

  // Complete task mutation
  const completeMutation = useMutation({
    mutationFn: async ({ taskId, notes }: { taskId: string; notes: string }) => {
      return scheduleAPI.completeBlockWithNotes(taskId, notes);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['today-summary'] });
      queryClient.invalidateQueries({ queryKey: ['schedule'] });
      setShowNotesModal(false);
      setActiveTask(null);
      setNotes('');
    },
  });

  // Filter to only training sessions
  const allBlocks = (todayData?.tasks || []) as TodayTask[];
  const tasks = allBlocks.filter((t: any) => 
    t.goal_id && !['work', 'commute', 'event', 'sleep', 'social'].includes(t.type)
  );
  const pendingTasks = tasks.filter((t) => t.status !== 'completed');
  const completedTasks = tasks.filter((t) => t.status === 'completed');

  const now = new Date();
  const isOverdue = (task: TodayTask) => {
    const scheduledEnd = new Date(new Date(task.scheduled_time).getTime() + task.duration_mins * 60000);
    return scheduledEnd < now && task.status !== 'completed';
  };

  const today = new Date().toLocaleDateString('en-GB', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
  });

  const handleComplete = (task: TodayTask) => {
    setActiveTask(task);
    setNotes('');
    setShowNotesModal(true);
  };

  const handleActivityLogged = () => {
    queryClient.invalidateQueries({ queryKey: ['today-summary'] });
    queryClient.invalidateQueries({ queryKey: ['schedule'] });
  };

  const handleTaskComplete = (taskId: string, notes: string) => {
    queryClient.invalidateQueries({ queryKey: ['today-summary'] });
  };

  // Task List Content
  const TaskListContent = () => (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className="p-4 md:p-6 border-b border-gray-200 bg-white/80">
        <div className="flex items-center gap-3 mb-1">
          <CalendarIcon className="w-5 h-5 md:w-6 md:h-6 text-purple-600" />
          <h1 className="text-xl md:text-2xl font-bold text-gray-900">Today</h1>
        </div>
        <p className="text-sm text-gray-600">{today}</p>

        {!isLoading && tasks.length > 0 && (
          <div className="flex gap-4 mt-3">
            <div className="flex items-center gap-2 text-sm">
              <Circle className="w-4 h-4 text-gray-400" />
              <span className="text-gray-600">{pendingTasks.length} to do</span>
            </div>
            <div className="flex items-center gap-2 text-sm">
              <CheckCircle className="w-4 h-4 text-green-500" />
              <span className="text-green-600">{completedTasks.length} done</span>
            </div>
          </div>
        )}
      </div>

      {/* Task List */}
      <div className="flex-1 overflow-y-auto p-4 md:p-6">
        {isLoading ? (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 text-purple-500 animate-spin" />
          </div>
        ) : tasks.length === 0 ? (
          <div className="text-center py-12">
            <div className="w-16 h-16 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <CalendarIcon className="w-8 h-8 text-purple-500" />
            </div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">No sessions today</h3>
            <p className="text-gray-500 text-sm">
              Rest day! Or generate a new schedule from the Schedule page.
            </p>
          </div>
        ) : (
          <div className="space-y-4">
            {pendingTasks.length > 0 && (
              <div>
                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">
                  To Do ({pendingTasks.length})
                </h2>
                <div className="space-y-3">
                  {pendingTasks.map((task) => (
                    <TodayTaskCard
                      key={task.id}
                      task={task}
                      onComplete={handleComplete}
                      isOverdue={isOverdue(task)}
                    />
                  ))}
                </div>
              </div>
            )}

            {completedTasks.length > 0 && (
              <div className="mt-6">
                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">
                  Completed ({completedTasks.length})
                </h2>
                <div className="space-y-3">
                  {completedTasks.map((task) => (
                    <TodayTaskCard
                      key={task.id}
                      task={task}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );

  return (
    <div className="flex flex-col lg:flex-row h-screen bg-gradient-to-br from-purple-50 via-white to-blue-50">
      {/* Mobile Tab Bar - Only visible on mobile */}
      <div className="lg:hidden fixed top-0 left-0 right-0 z-40 bg-white border-b border-gray-200 pt-safe">
        <div className="flex">
          <button
            onClick={() => setMobileTab('tasks')}
            className={`flex-1 flex items-center justify-center gap-2 py-3 text-sm font-medium transition-colors ${
              mobileTab === 'tasks'
                ? 'text-purple-600 border-b-2 border-purple-600 bg-purple-50/50'
                : 'text-gray-500'
            }`}
          >
            <ListTodo className="w-4 h-4" />
            Tasks
            {pendingTasks.length > 0 && (
              <span className="bg-purple-100 text-purple-600 text-xs px-1.5 py-0.5 rounded-full">
                {pendingTasks.length}
              </span>
            )}
          </button>
          <button
            onClick={() => setMobileTab('chat')}
            className={`flex-1 flex items-center justify-center gap-2 py-3 text-sm font-medium transition-colors ${
              mobileTab === 'chat'
                ? 'text-purple-600 border-b-2 border-purple-600 bg-purple-50/50'
                : 'text-gray-500'
            }`}
          >
            <MessageSquare className="w-4 h-4" />
            Pepzi AI
          </button>
        </div>
      </div>

      {/* Mobile Content Area */}
      <div className="lg:hidden flex-1 pt-12 pb-16 overflow-hidden">
        {mobileTab === 'tasks' ? (
          <div className="h-full overflow-y-auto bg-white/50 backdrop-blur-sm">
            <TaskListContent />
          </div>
        ) : (
          <div className="h-full">
            <TodayChat
              userId={userId}
              tasks={tasks}
              onActivityLogged={handleActivityLogged}
              onTaskComplete={handleTaskComplete}
            />
          </div>
        )}
      </div>

      {/* Desktop Layout - Side by side */}
      <div className="hidden lg:flex lg:flex-row flex-1 pt-16">
        {/* Left Side - Task List */}
        <div className="w-[55%] xl:w-[60%] border-r border-gray-200 bg-white/50 backdrop-blur-sm overflow-y-auto">
          <TaskListContent />
        </div>

        {/* Right Side - PA Chat */}
        <div className="w-[45%] xl:w-[40%] flex flex-col">
          <TodayChat
            userId={userId}
            tasks={tasks}
            onActivityLogged={handleActivityLogged}
            onTaskComplete={handleTaskComplete}
          />
        </div>
      </div>

      {/* Notes Modal */}
      {showNotesModal && activeTask && (
        <div className="fixed inset-0 bg-black/50 flex items-end lg:items-center justify-center z-50">
          <div className="bg-white rounded-t-2xl lg:rounded-2xl w-full lg:max-w-md shadow-xl max-h-[80vh] overflow-hidden">
            <div className="p-4 border-b">
              <h3 className="text-lg font-bold text-gray-900">Nice work! üéâ</h3>
              <p className="text-sm text-gray-500">{activeTask.name}</p>
            </div>
            
            <div className="p-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                How'd it go? (optional)
              </label>
              <textarea
                value={notes}
                onChange={(e) => setNotes(e.target.value)}
                placeholder="Any notes about this session..."
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:border-purple-500 focus:ring-2 focus:ring-purple-200 outline-none resize-none text-sm"
                rows={3}
                autoFocus
              />
              
              {activeTask.previous_notes && (
                <div className="mt-3 p-2 bg-gray-50 rounded-lg">
                  <p className="text-xs text-gray-500 font-medium mb-1">üìù Last time:</p>
                  <p className="text-xs text-gray-600">{activeTask.previous_notes}</p>
                </div>
              )}
            </div>

            <div className="p-4 border-t flex gap-3">
              <button
                onClick={() => {
                  setShowNotesModal(false);
                  setActiveTask(null);
                }}
                className="flex-1 px-4 py-3 border border-gray-200 text-gray-600 rounded-xl hover:bg-gray-50 font-medium"
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  if (activeTask) {
                    completeMutation.mutate({ taskId: activeTask.id, notes });
                  }
                }}
                disabled={completeMutation.isPending}
                className="flex-1 px-4 py-3 bg-green-500 text-white rounded-xl hover:bg-green-600 font-medium flex items-center justify-center gap-2 disabled:opacity-50"
              >
                <CheckCircle className="w-4 h-4" />
                {completeMutation.isPending ? 'Saving...' : 'Log It'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
--- goals/page.tsx ---
'use client';

import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { goalsAPI } from '@/lib/api';
import { useAuth } from '@/lib/auth-context';
import { Target, Plus, TrendingUp, Calendar, Clock, Trash2, Briefcase, Car, CalendarDays, Dumbbell } from 'lucide-react';
import AddGoalModal from '@/components/goals/AddGoalModal';
import GoalDetailView from '@/components/goals/GoalDetailView';
import type { Goal } from '@/lib/api';

export default function GoalsPage() {
  const { user } = useAuth();
  const userId = user?.id || '';
  const queryClient = useQueryClient();
  
  const [showAddGoal, setShowAddGoal] = useState(false);
  const [selectedGoal, setSelectedGoal] = useState<Goal | null>(null);
  const [deletingGoalId, setDeletingGoalId] = useState<string | null>(null);

  const { data: goals = [], isLoading } = useQuery({
    queryKey: ['goals', userId],
    queryFn: () => goalsAPI.getGoals(userId),
  });

  // Fetch real progress for all goals
  const { data: progressData } = useQuery({
    queryKey: ['goals-progress', userId],
    queryFn: () => goalsAPI.getAllProgress(userId),
    enabled: goals.length > 0,
  });

  // Fetch time budget
  const { data: timeBudget } = useQuery({
    queryKey: ['time-budget', userId],
    queryFn: () => goalsAPI.getTimeBudget(userId),
  });

  const deleteMutation = useMutation({
    mutationFn: (goalId: string) => goalsAPI.deleteGoal(goalId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['goals'] });
      queryClient.invalidateQueries({ queryKey: ['goals-progress'] });
      queryClient.invalidateQueries({ queryKey: ['time-budget'] });
    },
  });

  const handleDeleteGoal = async (e: React.MouseEvent, goalId: string, goalName: string) => {
    e.stopPropagation();
    
    const confirmed = window.confirm(
      `Are you sure you want to delete "${goalName}"?\n\nThis will permanently delete the goal and all its training plan data.`
    );

    if (!confirmed) return;

    setDeletingGoalId(goalId);
    try {
      await deleteMutation.mutateAsync(goalId);
      alert(`‚úÖ Deleted "${goalName}" successfully!`);
    } catch (error) {
      console.error('Failed to delete goal:', error);
      alert('‚ùå Failed to delete goal. Please try again.');
    } finally {
      setDeletingGoalId(null);
    }
  };

  const getCategoryColor = (category: string) => {
    const colors: { [key: string]: string } = {
      fitness: 'from-green-500 to-emerald-500',
      money: 'from-yellow-500 to-orange-500',
      skill: 'from-blue-500 to-indigo-500',
      social: 'from-pink-500 to-rose-500',
      travel: 'from-purple-500 to-violet-500',
      habit: 'from-cyan-500 to-teal-500',
      business: 'from-orange-500 to-red-500',
      experience: 'from-indigo-500 to-purple-500',
      climbing: 'from-orange-500 to-amber-500',
      languages: 'from-blue-500 to-indigo-500',
      creative: 'from-pink-500 to-rose-500',
      mental_health: 'from-cyan-500 to-teal-500',
    };
    return colors[category] || 'from-gray-500 to-slate-500';
  };

  // Helper to check if goal has a plan
  const hasPlan = (goal: Goal): boolean => {
    const planMicroGoals = goal.plan?.micro_goals;
    const microGoals = goal.micro_goals;
    return (Array.isArray(planMicroGoals) && planMicroGoals.length > 0) || 
           (Array.isArray(microGoals) && microGoals.length > 0);
  };

  // Calculate real progress percent
  const getRealProgress = (goal: Goal): { percent: number; hoursLogged: number; targetHours: number } => {
    const targetHours = goal.plan?.total_estimated_hours || 0;
    const goalProgress = progressData?.progress?.[goal.id];
    const hoursLogged = goalProgress?.total_hours || 0;
    const percent = targetHours > 0 ? Math.min(100, Math.round((hoursLogged / targetHours) * 100)) : 0;
    return { percent, hoursLogged, targetHours };
  };

  // Calculate goal breakdown for time budget
  const goalsWithPlans = goals.filter(g => g.plan?.weekly_hours > 0);

  if (selectedGoal) {
    return <GoalDetailView goal={selectedGoal} onBack={() => setSelectedGoal(null)} />;
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 via-white to-blue-50 p-4 md:p-8 pb-24 md:pb-8 md:pt-20">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-6 gap-4">
          <div>
            <h1 className="text-3xl md:text-4xl font-bold text-gray-900 mb-1">üéØ Your Goals</h1>
            <p className="text-gray-600 text-sm md:text-base">Track your progress and achieve your dreams</p>
          </div>
          
          <div className="flex gap-3 flex-wrap">
            <button
              onClick={() => setShowAddGoal(true)}
              className="px-5 py-2.5 bg-gradient-to-br from-purple-500 to-blue-500 text-white rounded-full font-medium hover:shadow-lg transition-all flex items-center gap-2"
            >
              <Plus className="w-5 h-5" />
              <span>Add Goal</span>
            </button>
          </div>
        </div>

        {/* Time Budget Dashboard */}
        <div className="mb-6 bg-white rounded-2xl shadow-md border border-gray-100 p-5">
          <div className="flex items-center gap-3 mb-4">
            <div className="w-10 h-10 bg-gradient-to-br from-purple-500 to-blue-500 rounded-xl flex items-center justify-center">
              <Clock className="w-5 h-5 text-white" />
            </div>
            <h2 className="text-lg font-bold text-gray-900">Weekly Time Budget</h2>
          </div>
          
          {/* Time Categories */}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-3 mb-4">
            <div className="bg-blue-50 rounded-xl p-3 text-center">
              <Briefcase className="w-5 h-5 text-blue-500 mx-auto mb-1" />
              <div className="text-2xl font-bold text-blue-600">{timeBudget?.work_hours || 0}h</div>
              <div className="text-xs text-blue-600/70 font-medium">Work</div>
            </div>
            <div className="bg-orange-50 rounded-xl p-3 text-center">
              <Car className="w-5 h-5 text-orange-500 mx-auto mb-1" />
              <div className="text-2xl font-bold text-orange-600">{timeBudget?.commute_hours || 0}h</div>
              <div className="text-xs text-orange-600/70 font-medium">Commute</div>
            </div>
            <div className="bg-pink-50 rounded-xl p-3 text-center">
              <CalendarDays className="w-5 h-5 text-pink-500 mx-auto mb-1" />
              <div className="text-2xl font-bold text-pink-600">{timeBudget?.event_hours || 0}h</div>
              <div className="text-xs text-pink-600/70 font-medium">Events</div>
            </div>
            <div className="bg-purple-50 rounded-xl p-3 text-center">
              <Dumbbell className="w-5 h-5 text-purple-500 mx-auto mb-1" />
              <div className="text-2xl font-bold text-purple-600">{timeBudget?.training_hours || 0}h</div>
              <div className="text-xs text-purple-600/70 font-medium">Training</div>
            </div>
            <div className="bg-green-50 rounded-xl p-3 text-center col-span-2 md:col-span-1">
              <div className="text-2xl font-bold text-green-600">{timeBudget?.free_hours || 0}h</div>
              <div className="text-xs text-green-600/70 font-medium">Free Time</div>
            </div>
          </div>

          {/* Progress bar showing committed vs awake hours */}
          <div className="mb-3">
            <div className="flex items-center justify-between text-sm mb-1">
              <span className="text-gray-600">Time committed</span>
              <span className="font-medium text-gray-900">
                {timeBudget?.committed_hours || 0}h / {timeBudget?.awake_hours || 112}h awake
              </span>
            </div>
            <div className="w-full h-3 bg-gray-100 rounded-full overflow-hidden">
              <div className="h-full flex">
                <div 
                  className="bg-blue-500 transition-all" 
                  style={{ width: `${((timeBudget?.work_hours || 0) / (timeBudget?.awake_hours || 112)) * 100}%` }}
                />
                <div 
                  className="bg-orange-500 transition-all" 
                  style={{ width: `${((timeBudget?.commute_hours || 0) / (timeBudget?.awake_hours || 112)) * 100}%` }}
                />
                <div 
                  className="bg-pink-500 transition-all" 
                  style={{ width: `${((timeBudget?.event_hours || 0) / (timeBudget?.awake_hours || 112)) * 100}%` }}
                />
                <div 
                  className="bg-purple-500 transition-all" 
                  style={{ width: `${((timeBudget?.training_hours || 0) / (timeBudget?.awake_hours || 112)) * 100}%` }}
                />
              </div>
            </div>
          </div>

          {/* Goal Breakdown */}
          {goalsWithPlans.length > 0 && (
            <div className="pt-3 border-t border-gray-100">
              <p className="text-xs text-gray-500 font-medium mb-2">TRAINING BREAKDOWN</p>
              <div className="space-y-1">
                {goalsWithPlans.map(goal => (
                  <div
                    key={goal.id}
                    className="flex items-center justify-between py-1.5 px-2 bg-gray-50 rounded-lg"
                  >
                    <div className="flex items-center gap-2">
                      <div className={`w-2.5 h-2.5 rounded-full bg-gradient-to-r ${getCategoryColor(goal.category)}`} />
                      <span className="text-sm text-gray-700">{goal.name}</span>
                    </div>
                    <span className="text-sm font-bold text-gray-900">{goal.plan?.weekly_hours}h/wk</span>
                  </div>
                ))}
              </div>
              {goals.filter(g => !g.plan?.weekly_hours).length > 0 && (
                <p className="text-xs text-gray-400 text-center pt-2">
                  + {goals.filter(g => !g.plan?.weekly_hours).length} goals without training plans
                </p>
              )}
            </div>
          )}
        </div>

        {/* Add Goal Modal */}
        <AddGoalModal
          isOpen={showAddGoal}
          onClose={() => setShowAddGoal(false)}
          onGoalCreated={() => {
            queryClient.invalidateQueries({ queryKey: ['goals'] });
            queryClient.invalidateQueries({ queryKey: ['time-budget'] });
            setShowAddGoal(false);
          }}
          userId={userId}
        />

        {/* Goals Grid */}
        {isLoading ? (
          <div className="text-center py-20">
            <div className="inline-block w-12 h-12 border-4 border-purple-500 border-t-transparent rounded-full animate-spin" />
          </div>
        ) : goals.length === 0 ? (
          <div className="text-center py-16">
            <div className="w-20 h-20 bg-gradient-to-br from-purple-100 to-blue-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <Target className="w-10 h-10 text-purple-500" />
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-2">No goals yet</h3>
            <p className="text-gray-600 mb-6 max-w-md mx-auto text-sm">
              Start your journey by adding your first goal!
            </p>
            <button
              onClick={() => setShowAddGoal(true)}
              className="px-6 py-3 bg-gradient-to-br from-purple-500 to-blue-500 text-white rounded-full font-medium hover:shadow-lg transition-all flex items-center gap-2 mx-auto"
            >
              <Plus className="w-5 h-5" />
              Add Your First Goal
            </button>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
            {goals.map((goal) => {
              const isDeleting = deletingGoalId === goal.id;
              const { percent: realProgressPercent, hoursLogged, targetHours } = getRealProgress(goal);
              const sessionsCount = progressData?.progress?.[goal.id]?.total_sessions || 0;
              
              return (
                <div
                  key={goal.id}
                  className="bg-white rounded-2xl p-5 shadow-md border border-gray-100 hover:shadow-xl transition-all cursor-pointer group relative"
                  onClick={() => setSelectedGoal(goal)}
                >
                  {/* Delete Button */}
                  <button
                    onClick={(e) => handleDeleteGoal(e, goal.id, goal.name)}
                    disabled={isDeleting}
                    className="absolute top-3 right-3 z-10 w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                    title="Delete goal"
                  >
                    {isDeleting ? (
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                    ) : (
                      <Trash2 className="w-4 h-4" />
                    )}
                  </button>

                  <div className={`w-12 h-12 bg-gradient-to-br ${getCategoryColor(goal.category)} rounded-xl flex items-center justify-center mb-3`}>
                    <Target className="w-6 h-6 text-white" />
                  </div>
                  
                  <h3 className="text-lg font-bold text-gray-900 mb-2 pr-8">{goal.name}</h3>
                  
                  <div className="flex items-center gap-2 text-sm mb-3 flex-wrap">
                    <span className="px-2.5 py-0.5 bg-purple-100 text-purple-700 rounded-full font-medium text-xs">
                      {goal.category}
                    </span>
                    {goal.target_date && (
                      <span className="flex items-center gap-1 text-gray-500 text-xs">
                        <Calendar className="w-3.5 h-3.5" />
                        {new Date(goal.target_date).toLocaleDateString()}
                      </span>
                    )}
                  </div>

                  {/* Progress section */}
                  {hasPlan(goal) ? (
                    <div>
                      <div className="flex items-center justify-between mb-1.5">
                        <span className="text-xs font-medium text-gray-600">Progress</span>
                        <span className="text-sm font-bold text-purple-600">
                          {realProgressPercent}%
                        </span>
                      </div>
                      <div className="w-full h-2 bg-gray-100 rounded-full overflow-hidden mb-2">
                        <div
                          className={`h-full bg-gradient-to-r ${getCategoryColor(goal.category)} transition-all duration-500`}
                          style={{ width: `${realProgressPercent}%` }}
                        />
                      </div>
                      <div className="flex items-center justify-between text-xs text-gray-500">
                        <span>
                          {hoursLogged}h / {targetHours}h
                        </span>
                        <span className="flex items-center gap-1">
                          <TrendingUp className="w-3 h-3" />
                          {sessionsCount} sessions
                        </span>
                      </div>
                    </div>
                  ) : (
                    <div className="text-center py-2 text-xs text-gray-500">
                      Click to create training plan
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}